#!/bin/sh

#################################################################
# MCServeMe – the terminal based Minecraft Java server launcher #
#################################################################

# This is free and unencumbered software released into the public domain.
# 
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
# 
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
# 
# For more information, please refer to <https://unlicense.org/>

# This script was originally created by Dennis “lortordermur” Murczak
# <https://github.com/lortordermur>

# Dependencies:
#
# - dialog
# - curl
# - jq
# - Any current Java runtime

# Optional dependencies:
#
# For moving data around more reliably:
# - rsync
#
# For backups:
# - zip
# - tar + gzip
# - 7za
# - rar

##################################
# Global constants and variables #
##################################

# Global constants are capitalized with UNDERSCORE_SPACING, global variables
# are CamelCase, and local variables always start with a lowercase letter.

# Math and logic constants

TRUE="0"
FALSE="1"

# Basic information

APP_NAME="MCServeMe"
SCRIPT_NAME=$(basename $0)
APP_DESC="MCJE server launcher for the terminal"
APP_VER="v0.01"
MAINTAINER="lortordermur"

# Whether we are in developer mode

DEV=$TRUE
[ $DEV ] && DEV_SUFFIX="-dev"

# Server types; for now only Fabric. When adding server types we would change
# the “SERVER_*” names to their plurals and use : as a separator.

DEFAULT_SERVER_TYPE="fabric"
DEFAULT_SERVER_TYPE_NAME="Fabric"

SERVER_TYPE="fabric"
SERVER_TYPE_NAME="Fabric"

# Fabric Meta API

FABRIC_API_URL="https://meta.fabricmc.net/v2"

# Common API‌ constants

API_CACHE_INTERVAL="3600" # seconds

# Filesystem related stuff

USER_DIR=$HOME
BACKUP_DIR=$USER_DIR

SCRIPT_DIR=$(dirname $0)

LOG_FILE="$USER_DIR/$APP_NAME.log"

TMP_DIR="/tmp"

TMP_FILE="$TMP_DIR/$APP_NAME-tmp"

CONFIG_DIR="$USER_DIR/.config/$APP_NAME"
CONFIG_FILE="$CONFIG_DIR/config"

LOCAL_DIR="$USER_DIR/.local/share/$APP_NAME"
JAR_DIR="$LOCAL_DIR/jars"
WORLD_DIR="$LOCAL_DIR/worlds"

BIN_DIR="$USER_DIR/.local/bin"

CACHE_DIR="$USER_DIR/.cache/$APP_NAME"
LIST_CACHE_DIR="$CACHE_DIR/lists"
DOCS_CACHE_DIR="$CACHE_DIR/docs"

# Some basic files for install/uninstall

README_FILE="README.md"
LICENSE_FILE="LICENSE"

# Other caches

EULA_CACHE_INTERVAL="86400" # seconds
EULA_URL="www.minecraft.net/eula"
EULA_FILENAME="EULA"
EULA_FILE="$DOCS_CACHE_DIR/$EULA_FILENAME"

AUTO_CACHE=$TRUE # Whether we want to update the API cache files on startup

GAME_VER_FILE="$LIST_CACHE_DIR/$SERVER_TYPE-gameversions"
LOADER_VER_FILE="$LIST_CACHE_DIR/$SERVER_TYPE-loaderversions"
INSTALLER_VER_FILE="$LIST_CACHE_DIR/$SERVER_TYPE-installerversions"

# The three server version list “arrays”

ServerVersionList=
ServerVersionListStable=
ServerVersionListInstalled=
NumServerVersions=
NumStableServerVersions=
NumInstalledServerVersions=

# Desktop directories

APPS_DIR="$USER_DIR/.local/share/applications"
ICON_THEME_DIR="$USER_DIR/.local/share/icons/hicolor"

# Default option values

DEFAULT_OPTION_JAR_DIR=$JAR_DIR
DEFAULT_OPTION_WORLD_DIR=$WORLD_DIR
DEFAULT_OPTION_BACKUP_DIR=$BACKUP_DIR
DEFAULT_OPTION_JAVA_MEMORY="2G"
DEFAULT_OPTION_TEXT_EDITOR="nano" # Default fallback editor
DEFAULT_OPTION_ARCHIVER="tgz" # Default archiver
DEFAULT_OPTION_AGREED_TO_EULA="false"

# Global option variables

OptionJavaMemory=$DEFAULT_OPTION_JAVA_MEMORY
OptionJarDir=$DEFAULT_OPTION_JAR_DIR
OptionWorldDir=$DEFAULT_OPTION_WORLD_DIR
OptionBackupDir=$DEFAULT_OPTION_BACKUP_DIR
OptionTextEditor=$DEFAULT_OPTION_TEXT_EDITOR
OptionArchiver=$DEFAULT_OPTION_ARCHIVER
OptionAgreedToEULA=$DEFAULT_OPTION_AGREED_TO_EULA

# Option variable keys

JarDirKey="jar-directory"
WorldDirKey="world-directory"
BackupDirKey="backup-directory"
JavaMemoryKey="java-memory"
TextEditorKey="text-editor"
ArchiverKey="archiver"
AgreedToEULAKey="agreed-to-eula"

# Common dialog options

NAVIGATION_DELAY="1" # Seconds of delay after interacting with a dialog
INFO_DELAY="3" # A somewhat longer delay for infobox chains
LONG_DELAY=$(($INFO_DELAY * 2))
DIALOG_COMMON_MIN="--colors --column-separator ' ' --sleep $NAVIGATION_DELAY --stdout"
DIALOG_COMMON="$DIALOG_COMMON_MIN --defaultno --scrollbar"

# Default dialog sizes

MAIN_MENU_SIZE="22 78 22"
INFOBOX_SIZE="6 60"
MESSAGEBOX_SIZE="8 60"
DECISION_BOX_SIZE="9 50"
PROGRAM_BOX_SIZE="-2 -2"
INPUTBOX_SIZE="7 60"
DIR_SELECTOR_SIZE="22 60"

# Dialog return codes

DIALOG_RET_ERROR="-1"
DIALOG_RET_OK="0"
DIALOG_RET_CANCEL="1"
DIALOG_RET_HELP="2"
DIALOG_RET_EXTRA="3"
DIALOG_RET_TIMEOUT="5"
DIALOG_RET_ESC="255"

# Miscellaneous constants

SHEBANG='#!/bin/sh\n'

CONFIG_HEADER="# Generated by $APP_NAME $APP_VER\n"

NOWHERE="/dev/null"

PING_IP="8.8.8.8" # Google DNS
CONNECTION_TIMEOUT="30" # seconds
CONNECTION_RETRIES="2"
USER_AGENT="$APP_NAME $APP_VER$DEV_SUFFIX (curl $(curl --version | head -n 1 | cut -d " " -f 2); $(uname -si); github.com/$MAINTAINER)"

CURL_OPTIONS="--connect-timeout $CONNECTION_TIMEOUT --retry $CONNECTION_RETRIES"
CURL_OPTIONS_USER_AGENT="$CURL_OPTIONS --user-agent \"$USER_AGENT\" "
CURL_OPTIONS_FOLLOW="$CURL_OPTIONS -L --max-redirs 2"
CURL_OPTIONS_USER_AGENT_FOLLOW="$CURL_OPTIONS_USER_AGENT -L --max-redirs 2"

ICON_DIMENSIONS="512" # Dimensions of the bundled desktop icon

KICKSTART=$FALSE # Whether the script was kickstarted

# Custom color scheme for ‘dialog’

UI_COLORS="\n
screen_color = (GREEN,BLACK,ON)\n
\n
shadow_color = (BLACK,BLACK,ON)\n
\n
title_color = (YELLOW,WHITE,ON)\n
\n
item_selected_color = (YELLOW, GREEN, ON)\n
tag_selected_color = (YELLOW,GREEN,ON)\n
button_active_color = (YELLOW,GREEN,ON)\n
\n
button_label_active_color = (WHITE,GREEN,ON)\n
button_key_active_color = (WHITE,GREEN,ON)\n
tag_key_selected_color = (WHITE,GREEN,ON)\n
position_indicator_color = (WHITE,GREEN,ON)\n
\n
button_inactive_color = (YELLOW,WHITE,OFF)\n
button_key_inactive_color = (YELLOW,WHITE,OFF)\n
tag_key_color = (YELLOW,WHITE,OFF)\n
\n
tag_color = (BLACK,WHITE,OFF)\n
\n
button_label_inactive_color = (BLACK,WHITE,ON)\n
uarrow_color = (BLACK,WHITE,ON)\n
darrow_color = (BLACK,WHITE,ON)"

##############
# Procedures #
##############

# Quickly reset/unbork the terminal by sending ESC

resetTerminal () {
  printf "%b" "\033c"
}

# Portable echo

echo () {
  printf "%b\n" "$*"
}

# Return the name of the OS kernel

getKernel () {
                   kernel=$(uname -s) # POSIX-style
  [ "$kernel" ] || kernel=$(sysctl -n kern.ostype) # Unix-style
  [ "$kernel" ] || kernel=$(sysctl -n kernel.ostype) # Linux-style
  [ "$kernel" ] || return $FALSE

  echo $kernel
}

# Return the machine architecture

getArch () {
                 arch=$(uname -m) # POSIX-style
  [ "$arch" ] || arch=$(sysctl -n kern.arch) # Unix-style
  [ "$arch" ] || arch=$(sysctl -n kernel.arch) # Linux-style
  [ "$arch" ] || return $FALSE
  
  echo $arch
}

# Return the type of graphical session, if any, as specifically as possible

getDesktop () {
  # First check whether we are on a non-graphical tty

  desktop=$XDG_SESSION_TYPE

  if [ "$desktop" = "tty" ]; then
    desktop="TTY"
    echo $desktop
    return $FALSE
  fi

  # Check all eligible environment variables
  
  desktop=$XDG_CURRENT_DESKTOP
  [ "$desktop" ]         || desktop=$DESKTOP_SESSION
  [ "$desktop" ]         || desktop=$XDG_SESSION_TYPE
  [ "$desktop" ]         || desktop=$TERM # This should work on macOS

  # xterm as fallback

  $(echo $desktop | grep -e "^xterm") && desktop="xterm"
  
  if [ ! "$desktop" ]; then
    desktop="unknown DE"
    echo $desktop
    return $FALSE
  fi

  echo $desktop
}

# As the name says. $1 signifies what Enter will do

waitForEnter () {
  what="continue"
  
  [ "$1" ] && what=$1
  
  echo
  echo "\e[1;32mPress Enter to $what …\033[0m"
  read "enter" 2>&1 > $NOWHERE
  sleep $NAVIGATION_DELAY
}

# Check whether a file exists and is a regular file or symlink

fileExists () {
  [ -f $* ] || [ -h $* ]
}

# Check whether a file exists and is a regular file

fileExistsRegular () {
  [ -f $* ]
}

# Check whether a file exists and is r/w

fileAccessible () {
  [ -r $* ] && [ -w $* ]
}

# Last modified time of file $1 in epoch seconds

fileLastModified () {
  echo $(stat -c %Y "$1")
}

# Check if directory $1 is empty

directoryEmpty () {
  [ -z $(ls -A $1) ]
}

# Seconds since the epoch

now () {
  echo $(date +%s)
}

# Format dialog text $1 reverse red

textFormatError () {
  echo "\Z1\Zr $* \Zn"
}

# Format dialog text $1 reverse black

textFormatEmphasis () {
  echo "\Z0\Zr $* \Zn"
}

# Replace spaces with non-break spaces. Use this when passing a server version
# with spaces in the name.

nameWithSpaces () {
  echo "$1" | NBSPToSpace
}

# Convert spaces from stdin to no-break spaces.

spaceToNBSP () {
  sed "s/ / /g"
}

# Convert no-break spaces from stdin to spaces.

NBSPToSpace () {
  sed "s/ / /g"
}

# Non-interactive error-and-out message for kickstart.

errorExit () {
  echo "\033[1;31m$@\033[0m" 1>&2
  exit $FALSE
}

# Follow a symlink chain starting with $1, which must be an executable (the
# path portion may be omitted if it is in the search path). If anything is
# given as a second argument, for example "verbose", the output is verbose
# with infoboxes.

followExecutableSymlinks () {
  verbose=$2
  file=$1
  previousFile=

  [ "$verbose" ] && dialogInfo "Resolving symlink chain …" && sleep $NAVIGATION_DELAY
  
  while file=$(readlink $(command -v $file)); do
    [ "$verbose" ] && dialogInfo "Resolving $(textFormatEmphasis $file) …" && sleep $NAVIGATION_DELAY
    previousFile=$file
  done
  
  echo $previousFile
}

# Check whether a command is available in the system.

commandExists () {
  command -v $@ > $NOWHERE
}

# Check whether command $1 is available in the system and optionally recommend
# installing the required package $2.

verifyDependency () {
  errorText=
  cmd=$1; pkg=$2
  
  if ! commandExists $cmd; then

    if [ $KICKSTART = $TRUE ]; then
      errorText="Dependency error: Command ‘$cmd’ is not available!"
      [ $pkg ] && errorText="$errorText Try installing the ‘$pkg’ package. --Exiting."
      errorExit "$errorText"
    else
      errorText="Command ‘$(textFormatError $cmd)’ is not available!"
      [ $pkg ] && errorText="$errorText Please install the ‘$(textFormatError $pkg)’ package. Exiting."
      dialogMessage "Required dependency missing" "$errorText"
    fi

    exit $FALSE
  fi
}

# Determine the editor to use

detectTextEditor () {
  editor=

  if [ "$EDITOR" ]; then
    dialogInfo "’EDITOR’ environment variable is set …"
    editor=$EDITOR
    sleep $INFO_DELAY
  elif commandExists "editor"; then # On systems with update-alternatives
    target=$(followExecutableSymlinks editor)
    dialogInfo "‘editor’ symlink is present, pointing to $(textFormatEmphasis $target) …"
    editor="editor"
    sleep $INFO_DELAY
  elif commandExists "$DEFAULT_OPTION_TEXT_EDITOR"; then
    dialogInfo "Using internal default ‘$DEFAULT_OPTION_TEXT_EDITOR’ …"
    editor=$DEFAULT_OPTION_TEXT_EDITOR
    sleep $INFO_DELAY
  else
    dialogInfo "‘$DEFAULT_OPTION_TEXT_EDITOR’ not found, falling back to ‘vi’ …"
    editor="vi" # Should be installed just about everywhere
    sleep $INFO_DELAY
  fi
  
  echo $editor
}

# Return the version of the installed default Java runtime

getJavaVersion () {
  java --version | head -n 1
}

# Download and dump to stdout. Typically $1 would be one of the $CURL_OPTIONS*
# constants and $2 the URL to download from

download () {
  curl -s $@
}

# Check whether a server version is installed. $1 is the version as displayed
# in the server lists. $2 (optional) is the server type and defaults to
# “$SERVER_TYPE”

isServerInstalled () {
  serverVersion=$1
  [ -z "$2" ] && serverType=$SERVER_TYPE || serverType=$2
  prefix="$(serverPrefix $serverVersion $serverType)"

  fileExists "$OptionJarDir/$prefix/$prefix.jar" && return $TRUE || return $FALSE
}

# Compare $1 and $2 server version, return true if $1 is newer. $3 (optional)
# is the server type

isServerVersionNewer () {
  ! fileAccessible $GAME_VER_FILE && return $FALSE
  
  serverListJSON=$(cat $GAME_VER_FILE)
  NumServerVersions=$(echo $serverListJSON | jq ". | length")

  lhs=; rhs=
  
  serverCounter="0"

  while [ "$serverCounter" -lt "$NumServerVersions" ]; do
    server=$(echo $serverListJSON | jq -r ".[$serverCounter].version" | spaceToNBSP)

    server=$1 && lhs=$serverCounter
    server=$2 && rhs=$serverCounter

    serverCounter=$((serverCounter + 1))
  done

  if [ $lhs ] && [ $rhs ]; then
    [ $lhs -gt $rhs ] && return $TRUE
  fi
  
  return $FALSE
}

# Get the version of latest server jar, whether stable or not. $1 (optional)
# signifies the server type

getLatestServerVersion () { 
  fileAccessible $GAME_VER_FILE || return $FALSE;
  echo $(cat $GAME_VER_FILE | jq -r ".[0].version")
  return $TRUE
}

# Get the version of latest stable server jar, optionally provide $1 for the
# server type

getLatestStableServerVersion () {
  ! fileAccessible $GAME_VER_FILE && echo "unknown" && return $FALSE
  
  serverListJSON=$(cat $GAME_VER_FILE)
  NumServerVersions=$(echo $serverListJSON | jq ". | length")

  serverCounter="0"

  while [ "$serverCounter" -lt "$NumServerVersions" ]; do
    isStable=$(echo $serverListJSON | jq -r ".[$serverCounter].stable")
    
    if [ $isStable = "true" ]; then
      echo $(echo $serverListJSON | jq -r ".[$serverCounter].version" | spaceToNBSP)
      return $TRUE
    fi

    serverCounter=$((serverCounter + 1))
    
  done
  
  echo "unknown"
  return $FALSE
}

# Return the latest installed server, whether stable or not. A supplied $1
# signifies the server type.

getLatestInstalledServerVersion () {
  serverType=$1

  [ -z $serverType ] && serverType=$SERVER_TYPE
  ! fileAccessible $GAME_VER_FILE && echo "unknown" &&‌ return $FALSE
  
  serverListJSON=$(cat $GAME_VER_FILE)
  NumServerVersions=$(echo $serverListJSON | jq ". | length")

  serverCounter="0"

  while [ "$serverCounter" -lt "$NumServerVersions" ]; do
    version=$(echo $serverListJSON | jq -r ".[$serverCounter].version" | spaceToNBSP)
    isServerInstalled $version $serverType && echo $version && return $TRUE

    serverCounter=$((serverCounter + 1))
  done

  echo "unknown"
  return $FALSE
}

# Check whether we need to update something in the cache. $1 is a single
# filename, $2 is the update interval in seconds

needToCache () {
  file=$1
  interval=$2

  [ ! "$interval" ] && $interval="3600" # default to one hour

  timeLastCaching="0"
  timeNow=$(now)
  timeDiff=
  ret=$FALSE

  if fileExistsRegular $file; then
    timeLastCaching=$(fileLastModified $file)
    timeDiff=$(($timeNow - $timeLastCaching))
    [ $timeDiff -ge $interval ] && ret=$TRUE
  fi

  return $ret
}

# Get server/loader/installer lists from Fabric Meta and cache them to disk
# (see: https://github.com/FabricMC/fabric-meta)

cacheFabricMeta () {
  dialogInfo "Caching game versions …"
  download "$CURL_OPTIONS_USER_AGENT" "$FABRIC_API_URL/versions/game" > $GAME_VER_FILE
  
  if [ ! -s "$GAME_VER_FILE" ] && fileExists $GAME_VER_FILE; then
    dialogMessage "Caching error" "There was a problem updating the game version list! Exiting."
    exit $FALSE
  fi
  
  dialogInfo "Caching loader versions …"
  download "$CURL_OPTIONS_USER_AGENT" "$FABRIC_API_URL/versions/loader" > $LOADER_VER_FILE

  if [ ! -s "$LOADER_VER_FILE" ] && fileExists $LOADER_VER_FILE; then
    dialogMessage "Caching error" "There was a problem updating the loader list! Exiting."
    exit $FALSE
  fi

  dialogInfo "Caching installer versions …"
  download "$CURL_OPTIONS_USER_AGENT" "$FABRIC_API_URL/versions/installer" > $INSTALLER_VER_FILE
  
  if [ ! -s "$INSTALLER_VER_FILE" ] && fileExists $INSTALLER_VER_FILE; then
    dialogMessage "Caching error" "There was a problem updating the installer list! Exiting."
    exit $FALSE
  fi
}

cacheEULA () {
  dialogInfo "Caching Minecraft EULA …"
  download "$CURL_OPTIONS_FOLLOW" "$EULA_URL" | HTMLToText | HTMLEULAFilter > $EULA_FILE
  
  if [ ! $? ] && fileExists $EULA_FILE; then
    dialogMessage "Caching error" "There was a problem updating the EULA file! Please read the text on $EULA_URL before installing a server with this software."
  fi
}

# Build the server lists from the list caches and the jars directory.
# $1 is the server type.
# The results are stored in the global server lists:
# ServerVersionList, ServerVersionListStable and ServerVersionListInstalled

# TODO: Set this up for different server types (Fabric, vanilla etc.)

buildServerLists () {
  if ! fileExists $GAME_VER_FILE; then
    if [ ! $KICKSTART = $TRUE ]; then
      dialogMessage "Empty list cache" "No version file in the list cache! Try $(textFormatEmphasis "force update list cache") in the main menu."
      return $FALSE
    else # Kickstart cannot continue here because it is non-interactive
      dialogInfo "The list cache is empty! Try $(textFormatEmphasis "force update list cache") in the main menu."
      sleep $LONG_DELAY
      exit $FALSE
    fi
  fi

  ServerVersionList=; ServerVersionListStable=; ServerVersionListInstalled=
  serverVersion=

  serverListJSON=$(cat $GAME_VER_FILE)

  [ -z "$1" ] && serverType=$SERVER_TYPE || serverType=$1
  
  NumServerVersions=$(echo $serverListJSON | jq ". | length")
  NumStableServerVersions="0"
  NumInstalledServerVersions="0"

  dialogInfo "Building server lists for server type ‘$serverType’ …"

  serverCounter="0"

  while [ "$serverCounter" -lt "$NumServerVersions" ]; do

    serverVersion=$(echo $serverListJSON | jq -r ".[$serverCounter].version" | spaceToNBSP)
    ServerVersionList="$ServerVersionList$serverVersion "

    isStable=$(echo $serverListJSON | jq -r ".[$serverCounter].stable")
    isServerInstalled "$serverVersion" "$serverType" && isInstalled="true" || isInstalled="false"

    if [ $isInstalled = "true" ]; then
      NumInstalledServerVersions=$((NumInstalledServerVersions + 1))
      ServerVersionListInstalled="$ServerVersionListInstalled$serverVersion "
      installedChar="I"
      $isStable && stableChar="S" || stableChar="u"
      ServerVersionListInstalled="$ServerVersionListInstalled$installedChar$stableChar "
    else
      installedChar="a"
    fi
    
    if [ $isStable = "true" ]; then
      NumStableServerVersions=$((NumStableServerVersions + 1))
      ServerVersionListStable="$ServerVersionListStable$serverVersion "
      stableChar="S"
      ServerVersionListStable="$ServerVersionListStable$installedChar$stableChar "
    else
      stableChar="u"
    fi

    ServerVersionList="$ServerVersionList$installedChar$stableChar "
    serverCounter=$((serverCounter + 1))
  done
}

# Convert HTML to plain text using sed. From left to right: Remove tags,
# delete blank lines, insert one blank line after each paragraph, delete lines
# with only spaces

HTMLToText () {
  sed -e 's/<[^>]*>//g' -e '/^$/d' -e 's/$/\n/' -e '/^\s*$/d'
}

# Snippet to remove some leftover script code from the Minecraft EULA

HTMLEULAFilter () {
  sed -e '/^\s*$/d' -e '/EULA | Minecraft/,/}(window);/d' -e '/.pageBottom/d'
}

# Make a prefix (e.g. for file or directory names) from $1 (server version)
# and $2 (server type)

serverPrefix () {
  serverVersion="$1"
  [ -z "$2" ] && serverType=$SERVER_TYPE || serverType="$2"

  echo "$serverType-server-$serverVersion"
}

# Show a message box dialog with title $1 and text $2

dialogMessage () {
  dialog $DIALOG_COMMON --title "$1" --msgbox "$2" $MESSAGEBOX_SIZE
}

# Show a simple titleless box with some text

dialogInfo () {
  dialog $DIALOG_COMMON --infobox "$*" $INFOBOX_SIZE
}

# Takes a command’s output and continually displays it in a box with text $1
# until finished, then adds an OK button

dialogProgram () {
  dialog $DIALOG_COMMON --programbox "$1" $PROGRAM_BOX_SIZE
}

# Yes/No dialog with title $1 and text $2

dialogYesNo () {
  dialog $DIALOG_COMMON --title "$1" --yesno "$2" $DECISION_BOX_SIZE
}

# Ok/Cancel dialog with title $1 and text $2

dialogOkCancel () {
  dialog $DIALOG_COMMON --yes-label "Ok" --no-label "Cancel" --title "$1" --yesno "$2" $DECISION_BOX_SIZE
}

# Input dialog with title $1, text $2 and (optional) init $3

dialogInput () {
  dialog $DIALOG_COMMON_MIN --title "$1" --inputbox "$2" $INPUTBOX_SIZE "$3"
}

# Directory selection dialog with title $1 and starting directory $2

dialogDirSelect (){
  dialog $DIALOG_COMMON --title "$1" --dselect "$2" $DIR_SELECTOR_SIZE
}

# Progress bar with title $1, text $2 and (optional) initial percentage $3

dialogProgress () {
  dialog $DIALOG_COMMON --title "$1" --gauge "$2" $MESSAGEBOX_SIZE "$3"
}

# Show the server list. $1 = "stable" for stable servers only, "installed" for
# installed ones, otherwise "all".
# $2 (optional) is the server type, for example "fabric"

menuServerList () {
  [ ! "$ServerVersionList" ] && dialogMessage "Server version list empty" "The list of server versions is null! Try $(textFormatEmphasis "force update list cache") in the main menu." && return $FALSE

  serverSubset=$1
  [ "$2" ] && serverType="$2" || serverType=$SERVER_TYPE
  
  case $serverSubset in
    installed)
      menuList=$ServerVersionListInstalled
      howMany=$NumInstalledServerVersions
      if [ $howMany = "0" ]; then
        dialogMessage "No servers" "You do not have any servers installed! Please pick one from the ‘stable’ or ‘all’ list."
        return $FALSE
      fi ;;
    stable)
      menuList=$ServerVersionListStable
      howMany=$NumStableServerVersions ;;
    all)
      menuList=$ServerVersionList
      howMany=$NumServerVersions ;;
    *)
      return $FALSE;
  esac
  
  while true; do
    choice=$(
    dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "Server selection ($serverSubset)" --menu \
  "$howMany $serverType server(s) found. Select a server jar to download, manage or launch.\n\n \
  I = installed, a = available, S = stable, u = unstable" \
  $MAIN_MENU_SIZE \
    $menuList
    )

    if [ "$choice" ]; then
      isServerInstalled "$choice" "$serverType" && menuInstalledServer $choice || menuAvailableServer $choice
    else
      break
    fi

  done
}

# Menu for installed servers

menuInstalledServer () {
  serverVersion=$1
  [ "$2" ] && serverType="$2" || serverType=$SERVER_TYPE
  
  while true; do
    choice=$(
    dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "Installed server" --menu \
  "Manage the $serverVersion ($serverType) server installation." \
  $MAIN_MENU_SIZE \
    "s" "Start server" \
    "w" "Select world" \
    "p" "Edit $(textFormatEmphasis "server.properties")" \
    "b" "Backup" \
    "c" "Erase world cache" \
    "u" "Uninstall"
    )

    case $choice in
      s)
        runServer $serverVersion $serverType ;;
      w)      
        continue ;;
      p)
        $OptionTextEditor "$OptionJarDir/$(serverPrefix $serverVersion $serverType)/server.properties" ;;
      b)      
        continue ;;
      c)
        continue ;;
      u)
        uninstallServer $serverVersion $serverType ;;
      *)
        break ;;
    esac

  done
}

# World menu for servers

menuWorlds () {
  serverVersion=$1
  [ "$2" ] && serverType="$2" || serverType=$SERVER_TYPE

  while true; do
    choice=$(
    dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "Server world on $serverType-$serverVersion" --menu \
  "World $worldName (using $worldSize of storage)." \
  $MAIN_MENU_SIZE \
    "r" "Rename world" \
    "b" "Backup/restore" \
    "p" "Purge world" \
    "d" "Delete world"
    )

    case $choice in
      r)
        continue ;;
      m)
        continue ;;
      b)
        continue ;;
      p)
        continue ;;
      d)      
        continue ;;
      *)
        break ;;
    esac

  done
}

# Menu for servers that are not installed

menuAvailableServer () {
  serverVersion=$1
  [ "$2" ] && serverType="$2" || serverType=$SERVER_TYPE
  
  while true; do
    choice=$(
    dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "Available server menu" --menu \
  "Options for downloadable servers." \
  $MAIN_MENU_SIZE \
    "i" "Download and install $serverVersion ($serverType)"
    )

    case $choice in
      i)
        downloadServer "$1" "$2" && break ;;
      *)
        break ;;
    esac
  done
}

# Global options menu

menuGlobalOptions () {
  while true; do
    choice=$(
    dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "Global options" --menu \
  "Global and default options." \
  $MAIN_MENU_SIZE \
    "m" "Java memory" \
    "j" "Server jar root folder" \
    "w" "World root folder" \
    "b" "Backup folder" \
    "e" "Default text editor" \
    "a" "Default archiver" \
    "i" "Install $APP_NAME" \
    "u" "Uninstall $APP_NAME" \
    "g" "Agree to the Minecraft EULA" \
    "r" "Reset to default settings"
    )

    case $choice in
      m)
        optionUIJavaMemory ;;
      j)
        optionUIJarFolder ;;
      w)
        optionUIWorldFolder ;;
      b)
        optionUIBackupFolder ;;
      e)
        optionUITextEditor ;;
      a)
        optionUIArchiver ;;
      i)
        installScript ;;
      u)
        uninstallScript ;;
      g)
        optionUIAgreeToEULA ;;
      r)
        dialogYesNo "Options reset" "Revert all global settings to their defaults?" && factoryReset ;;
      *)
        break ;;
    esac

  done
}

# The main menu.

menuMain () {
  # Main menu loop

  while true; do
    choice=$(
    dialog $DIALOG_COMMON --no-cancel --erase-on-exit --title "Main menu" --menu \
  "Welcome to $APP_NAME – $APP_DESC\n\n \
  Launcher version: $APP_VER on $(getDesktop)/$(getKernel) $(getArch)\n \
  Java version: $(getJavaVersion)\n \
  Latest server jar: $(getLatestServerVersion), stable: $(getLatestStableServerVersion), installed: $(getLatestInstalledServerVersion)\n" \
  $MAIN_MENU_SIZE \
      "r" "Run latest stable server" \
      "i" "Installed servers" \
      "s" "Available servers (stable)" \
      "a" "Available servers (all)" \
      "u" "Force update list cache" \
      "o" "Global options" \
      "x" "Exit $APP_NAME"
      )
    
    case $choice in
      r)
        instantServer ;;
      i)
        menuServerList "installed" ;;
      s)
        menuServerList "stable" ;;
      a)
        menuServerList "all" ;;
      u)
        onlineWarning "Cannot update the list cache without an internet connection." && cacheFabricMeta
        buildServerLists ;;
      o)
        menuGlobalOptions ;;
      *)
        break ;;
    esac
  done

  unInit
}

# Configuration UI for Java memory

optionUIJavaMemory () {
  value=$(dialogInput "Java Memory" ‌"Default amount of RAM for servers (recommended 2G-16G):" $OptionJavaMemory)

  if [ "$value" ]; then
    OptionJavaMemory=$value
    saveConfig
  fi
}

# Input box for the server jar directory

optionUIJarFolder () {
  while true; do
    
    dir=$(dialogInput "Server jar directory" "Root directory for the server jars:" $OptionJarDir)

    if [ "$dir" ] && [ -d $dir ]; then # Directory does exist
      OptionJarDir=$dir
      saveConfig
      break
    elif [ "$dir" ] && [ ! -d $dir ]; then # Directory does not exist

      if dialogYesNo "Invalid path" "The directory $(textFormatEmphasis $dir) does not exist, create it?"; then

        if mkdir -p $dir; then
          OptionJarDir=$dir
          saveConfig
          dialogMessage "Success" "The directory $(textFormatEmphasis $dir) has been created."
          break
        else
          dialogMessage "Error" "The directory $(textFormatEmphasis $dir) could not be created."
        fi
      fi
      
    elif [ -z "$dir" ]; then
      break
    fi
    
  done
}

# Input box for the world directory

optionUIWorldFolder () {
  while true; do
    
    dir=$(dialogInput "World directory" "Root directory for the worlds:" $OptionWorldDir)

    if [ "$dir" ] && [ -d $dir ]; then # Directory does exist
      OptionWorldDir=$dir
      saveConfig
      break
    elif [ "$dir" ] && [ ! -d $dir ]; then # Directory does not exist

      if dialogYesNo "Invalid path" "The directory $(textFormatEmphasis $dir) does not exist, create it?"; then

        if mkdir -p $dir; then
          OptionWorldDir=$dir
          saveConfig
          dialogMessage "Success" "The directory $(textFormatEmphasis $dir) has been created."
          break
        else
          dialogMessage "Error" "The directory $(textFormatEmphasis $dir) could not be created."
        fi
      fi
      
    elif [ -z "$dir" ]; then
      break
    fi
    
  done
}

# Input box for the backup directory

optionUIBackupFolder () {
  while true; do
    
    dir=$(dialogInput "Backup directory" "Root directory for backups:" $OptionBackupDir)

    if [ "$dir" ] && [ -d $dir ]; then # Directory does exist
      OptionBackupDir=$dir
      saveConfig
      break
    elif [ "$dir" ] && [ ! -d $dir ]; then # Directory does not exist

      if dialogYesNo "Invalid path" "The directory $(textFormatEmphasis $dir) does not exist, create it?"; then

        if mkdir -p $dir; then
          OptionBackupDir=$dir
          saveConfig
          dialogMessage "Success" "The directory $(textFormatEmphasis $dir) has been created."
          break
        else
          dialogMessage "Error" "The directory $(textFormatEmphasis $dir) could not be created."
        fi
      fi
      
    elif [ -z "$dir" ]; then
      break
    fi
    
  done
}

# Input box for the text editor to use

optionUITextEditor () {
  editor=
  
  dialogYesNo "Editor detection" "Would you like to autodetect the editor?" && editor=$(detectTextEditor)
  [ "$editor" ] || editor=$OptionTextEditor

  while true; do
    editor=$(dialogInput "Text editor" "Text editor to use:" $editor)

    if [ "$editor" ]; then
      OptionTextEditor=$editor
      saveConfig
      break
    else
      break
    fi

  done

  echo $editor
}

optionUIArchiver () {
  installed="*"
  
  tgzInstalled=
  zipInstalled=
  sevenZipInstalled=

  commandExists "tar" && commandExists "gzip" && tgzInstalled=$installed
  commandExists "zip" && zipInstalled=$installed
  commandExists "7z" || commandExists "7za" || commandExists "7zr" && sevenZipInstalled=$installed

  while true; do
    choice=$(
    dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "Archiver for backups" --menu \
  "Archiver to use for backups; currently $(textFormatEmphasis $OptionArchiver). $(textFormatEmphasis "*") denotes that the appropriate binaries are installed." \
  $MAIN_MENU_SIZE \
    "t" "Gzipped tar (.tgz) $tgzInstalled" \
    "z" "Zip (.zip) $zipInstalled" \
    "7" "7-Zip (.7z) $sevenZipInstalled"
    )

    case $choice in
      t)
        OptionArchiver="tgz"
        break ;;
      z)
        OptionArchiver="zip"
        break ;;
      7)
        OptionArchiver="7z"
        break ;;
      *)
        return $FALSE ;;
    esac

  done

  dialogMessage "Archiver set" "Default archiver has been set to $(textFormatEmphasis $OptionArchiver)."
}

# Ask the user to agree with the Minecraft EULA

optionUIAgreeToEULA () {
  agreed=$OptionAgreedToEULA
  
  if [ $agreed = "true" ]; then
    dialogMessage "EULA" "You already agreed to the Minecraft EULA."
  else
    if dialogYesNo "EULA" "Do you agree to the Minecraft EULA?\n$EULA_URL"; then
      OptionAgreedToEULA="true"
      dialogMessage "EULA" "Agreement acknowledged. You can now start servers."
    else
      dialogMessage "EULA" "You need to agree to the Minecraft EULA before you can start a server."
    fi
  fi
  
  writeConfigKey $CONFIG_FILE $AgreedToEULAKey $OptionAgreedToEULA
}

# Install the script file to the local bin directory. Optionally also install
# a desktop entry

installScript () {
  # Check if we are running an installed version
  [ $SCRIPT_DIR = $BIN_DIR ] && dialogMessage "Path error" "The $APP_NAME script is already installed. Please uninstall it first." && return $FALSE
  
  dialogYesNo "$APP_NAME installation" "Install the $(textFormatEmphasis $SCRIPT_NAME) script to $(textFormatEmphasis $BIN_DIR)?" || return
  
  if [ ! $(echo $PATH | grep $BIN_DIR) ]; then
    dialogYesNo "Path error" "$(textFormatEmphasis $BIN_DIR) is not in your PATH variable! Install anyway?" || return $FALSE
  fi

  dialogInfo "Installing the $APP_NAME script …"
  
  cp -fp $0 $BIN_DIR
  
  dialogInfo "Installing the documentation …"

  mkdir -p $LOCAL_DIR
  cp -f $README_FILE $LICENSE_FILE $LOCAL_DIR
  
  dialogMessage "Installation successful" "Script and documentation have been installed. You can now start $APP_NAME by typing $(textFormatEmphasis $SCRIPT_NAME) anywhere."

  # Optionally install a desktop entry if desktop-file-utils is installed
  
  # Check for the desktop assets under the script directory and the current directory

  desktopAssetsDir="$SCRIPT_DIR/desktop"
  [ ! -d $desktopAssetsDir ] && desktopAssetsDir="$(pwd)/desktop"
  [ ! -d $desktopAssetsDir ] && return
  
  if fileExistsRegular "$desktopAssetsDir/com.$MAINTAINER.$APP_NAME.desktop" &&
     fileExistsRegular "$desktopAssetsDir/$SCRIPT_NAME.svg" &&
     fileExistsRegular "$desktopAssetsDir/$SCRIPT_NAME.png"&&
     commandExists "desktop-file-install"; then

      if dialogYesNo "Desktop entry" "Do you also want to install a desktop icon and menu entry?"; then
        dialogInfo "Installing desktop file and icons …"

        mkdir -p $APPS_DIR "$ICON_THEME_DIR/scalable" $ICON_THEME_DIR/$ICON_DIMENSIONS"x"$ICON_DIMENSIONS
        cp -f "$desktopAssetsDir/$SCRIPT_NAME.svg" "$ICON_THEME_DIR/scalable/apps"
        cp -f "$desktopAssetsDir/$SCRIPT_NAME.png" $ICON_THEME_DIR/$ICON_DIMENSIONS"x"$ICON_DIMENSIONS"/apps"
        desktop-file-install --dir="$APPS_DIR" "$desktopAssetsDir/com.$MAINTAINER.$APP_NAME.desktop"
        
        dialogMessage "Installation successful" "The desktop assets have been installed."
      fi

  else
    return
  fi
}

# Remove the installed script and desktop entries from the system

uninstallScript () {
  if ! fileExists "$BIN_DIR/$SCRIPT_NAME"; then
    dialogMessage "No installation found" "The script is not installed."
    return
  fi

  dialogYesNo "Uninstall $APP_NAME" "Remove the $APP_NAME installation from your system?" || return

  rm -f "$ICON_THEME_DIR/scalable/$SCRIPT_NAME.svg"
  rm -f "$ICON_THEME_DIR/$ICON_DIMENSIONS"x"$ICON_DIMENSIONS/$SCRIPT_NAME.png"
  rm -f "$APPS_DIR/com.$MAINTAINER.$APP_NAME.desktop"
  
  rm -f "$LOCAL_DIR/$README_FILE" "$LOCAL_DIR/$LICENSE_FILE"

  rm -f "$BIN_DIR/$SCRIPT_NAME"

  commandExists update-desktop-database && update-desktop-database

  if directoryEmpty $LOCAL_DIR; then
    rmdir $LOCAL_DIR
  else
    dialogMessage "Leftover data" "There is still some data, possibly server jars or worlds, left in $(textFormatEmphasis $LOCAL_DIR). You should look over those manually."
  fi

  dialogMessage "Uninstall successful" "$APP_NAME has been removed."
}

# Load the global settings from the configuration file

loadConfig () {
  OptionJarDir=$(readConfigKey $CONFIG_FILE $JarDirKey $DEFAULT_OPTION_JAR_DIR)
  OptionWorldDir=$(readConfigKey $CONFIG_FILE $WorldDirKey $DEFAULT_OPTION_WORLD_DIR)
  OptionBackupDir=$(readConfigKey $CONFIG_FILE $BackupDirKey $DEFAULT_OPTION_BACKUP_DIR)
  OptionJavaMemory=$(readConfigKey $CONFIG_FILE $JavaMemoryKey $DEFAULT_OPTION_JAVA_MEMORY)
  OptionTextEditor=$(readConfigKey $CONFIG_FILE $TextEditorKey $DEFAULT_OPTION_TEXT_EDITOR)
  OptionArchiver=$(readConfigKey $CONFIG_FILE $ArchiverKey $DEFAULT_OPTION_ARCHIVER)
  OptionAgreedToEULA=$(readConfigKey $CONFIG_FILE $AgreedToEULAKey $DEFAULT_OPTION_AGREED_TO_EULA)
}

# Saves the configuration file

saveConfig () {
  echo $CONFIG_HEADER > $CONFIG_FILE

  writeConfigKey $CONFIG_FILE $JarDirKey $OptionJarDir
  writeConfigKey $CONFIG_FILE $WorldDirKey $OptionWorldDir
  writeConfigKey $CONFIG_FILE $BackupDirKey $OptionBackupDir
  writeConfigKey $CONFIG_FILE $JavaMemoryKey $OptionJavaMemory
  writeConfigKey $CONFIG_FILE $TextEditorKey $OptionTextEditor
  writeConfigKey $CONFIG_FILE $ArchiverKey $OptionArchiver
  writeConfigKey $CONFIG_FILE $AgreedToEULAKey $OptionAgreedToEULA
}

# Write the config file with the defaults

writeDefaultConfig () {
  dialogMessage "Initial configuration" "No configuration file was found; creating one in $(textFormatEmphasis $CONFIG_DIR)."

  echo $CONFIG_HEADER > $CONFIG_FILE

  writeConfigKey $CONFIG_FILE $JarDirKey $DEFAULT_OPTION_JAR_DIR
  writeConfigKey $CONFIG_FILE $WorldDirKey $DEFAULT_OPTION_WORLD_DIR
  writeConfigKey $CONFIG_FILE $BackupDirKey $DEFAULT_OPTION_BACKUP_DIR
  writeConfigKey $CONFIG_FILE $JavaMemoryKey $DEFAULT_OPTION_JAVA_MEMORY
  writeConfigKey $CONFIG_FILE $TextEditorKey $DEFAULT_OPTION_TEXT_EDITOR
  writeConfigKey $CONFIG_FILE $ArchiverKey $DEFAULT_OPTION_ARCHIVER
  writeConfigKey $CONFIG_FILE $AgreedToEULAKey $DEFAULT_OPTION_AGREED_TO_EULA
}

factoryReset () {
  OptionJarDir=$DEFAULT_OPTION_JAR_DIR
  OptionWorldDir=$DEFAULT_OPTION_WORLD_DIR
  OptionBackupDir=$DEFAULT_OPTION_BACKUP_DIR
  OptionJavaMemory=$DEFAULT_OPTION_JAVA_MEMORY
  OptionTextEditor=$DEFAULT_OPTION_TEXT_EDITOR
  OptionArchiver=$DEFAULT_OPTION_ARCHIVER
  OptionAgreedToEULA=$DEFAULT_OPTION_AGREED_TO_EULA

  saveConfig
  dialogMessage "Reset" "All global options have been reset."
}

# Read the value of a key=value pair from a configuration file.
# $1=file, $2=key, $3=default value (optional)

readConfigKey () {
  file=$1; key=$2; defaultValue=$3; value=

  ! fileAccessible $file && touch $file # Make sure the file exists

  value=$(grep -e "^$key=.*" $file | sed -e 's/ //g' | cut -d "=" -f 2)
  [ "$value" ] || value=$defaultValue

  echo $value
}

# Write a key=value pair to a configuration file.
# $1=file, $2=key, $3=value

writeConfigKey () {
  file=$1; key=$2; value=$3

  touch $file
  
  if fileAccessible $file; then # The file is there and we can read and write
    # Many non-GNU seds cannot modify data in-place, hence we need a tempfile

    #sed -e '/^#/!s/ //g' $file > $TMP_FILE # Sanitize the file and copy to /tmp
    cp -f $file $TMP_FILE

    if grep -e "^$key=.*" $TMP_FILE; then # Is the key in the file?
    
      if grep -e "^$key=$value$" $TMP_FILE; then
        return # Same value, outta here
      else
        #sed -e "s/^$key=.*/$key=$value/g" $file > $TMP_FILE # Update value
        sed -e "s/\($key *= *\).*/\1$value/g" $file > $TMP_FILE
      fi 

    else
      echo "$key=$value" >> $TMP_FILE # Key-value pair not present, append
    fi

    mv -f $TMP_FILE $file # Update the file with the changes
  
  else # File not accessible or nonexistent
    if [ $KICKSTART = $TRUE ]; then
      errorExit "ERROR: No write access to configuration file!"
    else
      dialogMessage "Filesystem error" "Cannot access the configuration file! Check directory permissions for $(dirname $file)."
      exit $FALSE
    fi
  fi
}

# Return true if we have internet connectivity

online () {
  ping -c 1 $PING_IP | grep -q "0%" > $NOWHERE
}

# A small wrapper around the ‘online’ function that displays $* as a message.

onlineWarning () {
  online && return $TRUE
  
  dialogMessage "No internet connectivity" "$*"
  
  return $FALSE
}

# Download and initialize the server of version $1 and (optionally) type $2

downloadServer () {
  matchFile="$LIST_CACHE_DIR/$SERVER_TYPE-loadermatch"

  serverVersion="$1"
  anyLoader=; stableLoader=
  installer=

  serverType=
  loaderJSON=

  [ -z "$2" ] && serverType=$SERVER_TYPE || serverType="$2"
  
  dialogInfo "Finding the best loader for $serverVersion ($serverType) …"

  download $CURL_OPTIONS_USER_AGENT "$FABRIC_API_URL/versions/loader/$serverVersion" > $matchFile

  loaderJSON=$(cat $matchFile)
  if [ ! "$loaderJSON" ]; then
    [ $KICKSTART = $FALSE ] && dialogMessage "Transmission error" "The loader match data could not be obtained."
    return $FALSE
  fi

  numLoaderVersions=$(echo $loaderJSON | jq ". | length")

  # Default to the newest loader whether stable or unstable
  
  anyLoader=$(echo $loaderJSON | jq -r ".[0].loader.version")

  # Then look for the newest stable loader

  stableLoader=; l="0"
  
  while [ $l -lt $numLoaderVersions ]; do
  
    stableLoader=$(echo $loaderJSON | jq -r ".[$l].loader.version")
    isStable=$(echo $loaderJSON | jq -r ".[$l].loader.stable")
  
    [ "$isStable" = "true" ] && break;
    
    l=$(($l + 1))
  done
  
  if [ "$anyLoader" = "$stableLoader" ]; then
    dialogInfo "Finding the best loader for $serverVersion ($serverType) … $stableLoader."
    sleep $INFO_DELAY
    loader=$stableLoader
  else
    dialogInfo "Finding the best loader for $serverVersion ($serverType) … several matches."

    if [ $KICKSTART = $FALSE ]; then
      dialogYesNo "Several loader matches" "Would you like to install the newer $(textFormatEmphasis "unstable") loader version $(textFormatEmphasis "$anyLoader") rather than the stable $(textFormatEmphasis "$stableLoader")? This is rather not recommended if you are running a stable server version." && loader=$anyLoader || loader=$stableLoader
    else
      loader=$stableLoader # Prefer stable versions in kickstart
    fi
  
  fi

  installerJSON=$(cat $INSTALLER_VER_FILE)
  [ ! "$installerJSON" ] && dialogMessage "Transmission error" "The installer data could not be obtained." && return $FALSE
  installer=$(echo $installerJSON | jq -r ".[0].version")
  
  dialogInfo "Creating directories …"
  serverDir="$OptionJarDir/$(serverPrefix $serverVersion $serverType)"
  mkdir -p $serverDir

  dialogInfo "Downloading $serverType server $serverVersion …"
  download "$FABRIC_API_URL/versions/loader/$serverVersion/$loader/$installer/server/jar" -o "$serverDir/$(serverPrefix $serverVersion $serverType).jar"

  echo
  echo "#################################"
  echo "### Server download completed ###"
  echo "#################################"
  echo
  
  initServer $serverVersion $serverType
}

# Initialize the server of version $1 and (optionally) type $2, auto-agreeing
# to the EULA if it has already been agreed to through the global options.

initServer () {
  serverVersion="$1"
  [ -z "$2" ] && serverType=$SERVER_TYPE || serverType="$2"

  dialogInfo "Initializing Server …"
  
  serverDir="$OptionJarDir/$(serverPrefix $serverVersion $serverType)"
  cd $serverDir
  
  resetTerminal

  echo $CONFIG_HEADER > eula.txt
  writeConfigKey eula.txt "eula" "$OptionAgreedToEULA"
  writeConfigKey "server.properties" "level-name" "$serverVersion"

  java -jar "$(serverPrefix $serverVersion $serverType).jar" --initSettings --nogui

  cd $SCRIPT_DIR

  echo
  echo "#######################################"
  echo "### Server initialization completed ###"
  echo "#######################################"
  echo

  [ $KICKSTART = $FALSE ] && waitForEnter "continue"
  resetTerminal

  [ $KICKSTART = $FALSE ] && buildServerLists
}

# Run the server of version $1 and (optionally) type $2

runServer () {
  serverVersion=$1
  [ "$2" ] && serverType="$2" || serverType=$SERVER_TYPE

  serverDir="$OptionJarDir/$(serverPrefix $serverVersion $serverType)"
  cd $serverDir

  # Agree to the EULA‌ if we have already agreed to it in the global options
  
  echo $CONFIG_HEADER > eula.txt
  writeConfigKey eula.txt "eula" "$OptionAgreedToEULA"
  
  if [ $KICKSTART = $TRUE ]; then
    dialogInfo "Launching ‘$(textFormatEmphasis $serverVersion \($serverType\))’. Type $(textFormatEmphasis "/stop") in the console to shut down the server."
    sleep $LONG_DELAY
  else
    dialogOkCancel "Launching server" "Launching ‘$(textFormatEmphasis $serverVersion \($serverType\))’. Use the $(textFormatEmphasis "/stop") console command to cleanly exit and return to the launcher." || return $FALSE
  fi
    
  cd $SCRIPT_DIR

  resetTerminal

  java -Xmx"$OptionJavaMemory" -jar "$(serverPrefix $serverVersion $serverType).jar" --universe $OptionWorldDir --nogui

  echo
  echo "#################################"
  echo "### Server shutdown completed ###"
  echo "#################################"
  echo
  
  [ $KICKSTART = $FALSE ] && waitForEnter "return to the launcher"
  resetTerminal
}

## Instant server. Downloads and runs the most recent stable version.

instantServer () {
  lssv=$(getLatestStableServerVersion $SERVER_TYPE)

  if ! isServerInstalled $lssv $SERVER_TYPE; then
    dialogYesNo "Server download" "The latest stable server is not installed. Download the $(textFormatEmphasis "‘$lssv ($serverType)’") server?" || return
    downloadServer $lssv $SERVER_TYPE
  fi

  runServer $lssv $SERVER_TYPE
  menuInstalledServer $lssv $SERVER_TYPE
}

# Uninstall the server of version $1 and type $2

uninstallServer () {
  serverVersion=$1
  [ "$2" ] && serverType="$2" || serverType=$SERVER_TYPE

  serverDir="$OptionJarDir/$(serverPrefix $serverVersion $serverType)"

  if dialogYesNo "Uninstall server" "Warning: This will delete $(textFormatError "everything") under $(textFormatEmphasis $serverDir), including any local world data! Make sure to have a backup of any needed data. Continue?"; then
    resetTerminal
    
    rm -rfv "$serverDir"

    echo
    echo "#################################"
    echo "### Server deletion completed ###"
    echo "#################################"
    echo

    waitForEnter "return to the installed servers menu"

    buildServerLists
    menuMain
    #menuServerList "installed" $serverType # FIXME: Go back to the installed server list without landing in the 18w43b menu thereafter
  fi
}

# Command line help

help() {
  echo \
"$APP_NAME $APP_VER – 2025-$(date +%Y), originally created by Dennis Murczak
<https://github.com/lortordermur>

Usage: $SCRIPT_NAME <arg>

  -n, --no-auto-cache
  Prevents $APP_NAME from automatically refreshing the API cache on startup.
  It can still be refreshed manually from the main menu. This is useful for
  systems that are not always connected to the internet.
  -k, --kickstart [type]
  Directly run the latest stable server version–downloading, installing and
  initializing it if necessary–and exit afterwards. This skips all user
  interaction except a pending EULA agreement, in which case it quits with an
  error message.
  -h, --help
  This help screen."
  
  # TODO:
  # -r, --run <version> [type]
  # -l, --run-latest [type]
  # -b, --backup <version> [type]
}

# Get and process the command line parameters

processArguments () {
  while [ "$1" ]; do
    # TODO: Shift the parameters so we can combine them
    case $1 in
      -n|--no-auto-cache)
        AUTO_CACHE=$FALSE ;;
      -k|--kickstart)
        KICKSTART=$TRUE ;;
      -h|--help)
        help
        exit $TRUE ;;
      *)
        echo "Unknown parameter! Try --help"
        exit $FALSE ;;
    esac
    
    shift
  done
}

# Stuff to do before showing the main menu

init () {
  
  # Set up logging of stderr to log file while still seeing it onscreen

  exec 2>> $LOG_FILE 2>&1 # FIXME: Creates a 0 byte logfile

  # Create the default directories
  
  mkdir -p $CONFIG_DIR $LIST_CACHE_DIR $DOCS_CACHE_DIR $OptionJarDir $OptionWorldDir

  # Write a default configuration file if there is none

  fileAccessible $CONFIG_FILE || writeDefaultConfig

  # Load the global options and defaults

  fileExists $CONFIG_FILE && loadConfig
  
  # Update the API cache if necessary

  onlineWarning "It seems there is no internet connection. Some functionality will be limited."
  
  [ $AUTO_CACHE = $TRUE ] && online && needToCache $GAME_VER_FILE $API_CACHE_INTERVAL && cacheFabricMeta
  
  [ $KICKSTART = $FALSE ] && buildServerLists
  
  #online && needToCache $EULA_FILE $EULA_CACHE_INTERVAL && cacheEULA # The EULA should always be cached

  if [ $KICKSTART = $TRUE ]; then
    dialogInfo "$(textFormatError "Kickstart mode"): Launching the newest server; no frills attached, no questions posed."
    sleep $LONG_DELAY
    kickStart
  fi
}

# Do the kickstart, let’s get down to business.
# $1 (optional) is the desired server type.

kickStart () {
  serverType=$1
  
  lssv=$(getLatestStableServerVersion $serverType)
  [ -z $lssv ] && lssv=$(getLatestInstalledServerVersion $serverType)
  [ -z $lssv ] && errorExit "KICKSTART: Could not determine the latest server version! Check your internet connection."

  ! isServerInstalled $lssv && downloadServer $lssv $serverType
  runServer $lssv $serverType
  unInit $TRUE
}

# Stuff to do on script exit

unInit () {
  saveConfig

  echo
  echo "\e[1;32mThank you for using $APP_NAME!\033[0m May the netherite pickaxe be with you."

  exit $1
}

################
# Main program #
################

# Evaluate the command line
  
processArguments $@

# Check for the UI toolkit

! commandExists "dialog" && errorExit "ERROR: The ‘dialog’ command is missing! Please install the ‘dialog’ package."

# Prepare dialogrc pre-init for a custom color scheme
# Drop a dialogrc named ‘colors’ there to customize the appearance

export DIALOGRC="$CONFIG_DIR/colors"
fileExists $DIALOGRC || echo $UI_COLORS > $DIALOGRC

# Root check

if [ $(id -u) = 0 ]; then
  dialogMessage "Root detected" "Running a game server as root $(textFormatError "is a bad idea"). Exiting."
  exit $FALSE
fi

# Software dependency checks

verifyDependency "java" "default-jre-headless"
verifyDependency "curl" "curl"
verifyDependency "jq" "jq"

init
menuMain
