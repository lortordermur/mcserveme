#!/bin/sh

#####################################################
# MCServeMe – MCJE server launcher for the terminal #
#####################################################

# This is free and unencumbered software released into the public domain.
# 
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
# 
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
# 
# For more information, please refer to <https://unlicense.org/>

# This script was originally created by Dennis “lortordermur” Murczak
# <https://github.com/lortordermur>

# Dependencies:
#
# - dialog
# - curl
# - jq
# - Any current Java runtime

# Optional dependencies for backups:
#
# - zip
# - tar + gzip
# - 7zr
#
# TODO: If available use rsync for copy/move file operations

##################################
# Global constants and variables #
##################################

# Global constants are capitalized with UNDERSCORE_SPACING, global variables
# are CamelCase, and local variables always start with a lowercase letter.

# Math and logic constants

TRUE="0"
FALSE="1"

# Whether we are in developer mode

DEV=$TRUE
[ "$DEV" ] && DEV_SUFFIX="-dev"

# Basic information

APP_NAME="MCServeMe"
SCRIPT_NAME=$(basename $0)
APP_DESC="MCJE server launcher for the terminal"
APP_VER="v0.04"
MAINTAINER="lortordermur"

# Server types; for now only Fabric. When adding server types we would change
# the “SERVER_*” names to their plurals and use : as a separator.

DEFAULT_SERVER_TYPE="fabric"
DEFAULT_SERVER_TYPE_NAME="Fabric"

SERVER_TYPE="fabric"
SERVER_TYPE_NAME="Fabric"

# Fabric Meta API

FABRIC_API_URL="https://meta.fabricmc.net/v2"

# Modrinth API

MODRINTH_API_URL="https://api.modrinth.com/v2"

# Common API‌ constants

LIST_CACHE_INTERVAL="14400" # seconds

# Filesystem related stuff

USER_DIR=$HOME
BACKUP_DIR=$USER_DIR

SCRIPT_DIR=$(dirname $0)

LOG_FILE="$USER_DIR/$APP_NAME.log"

TMP_DIR="/tmp"

TMP_FILE="$TMP_DIR/$APP_NAME-tmp"

CONFIG_DIR="$USER_DIR/.config/$APP_NAME"
CONFIG_FILE="$CONFIG_DIR/config"

LOCAL_DIR="$USER_DIR/.local/share/$APP_NAME"
JAR_DIR="$LOCAL_DIR/jars"
WORLD_DIR="$LOCAL_DIR/worlds"

BIN_DIR="$USER_DIR/.local/bin"

CACHE_DIR="$USER_DIR/.cache/$APP_NAME"
LIST_CACHE_DIR="$CACHE_DIR/lists"
DOCS_CACHE_DIR="$CACHE_DIR/docs"

# Some basic files for install/uninstall

README_FILE="README.md"
LICENSE_FILE="LICENSE"

# Other caches

EULA_CACHE_INTERVAL="86400" # seconds
EULA_URL="www.minecraft.net/eula"
EULA_FILENAME="EULA"
EULA_FILE="$DOCS_CACHE_DIR/$EULA_FILENAME"

AUTO_CACHE=$TRUE # Whether we want to update the list cache files on startup

GAME_VER_FILE="$LIST_CACHE_DIR/$SERVER_TYPE-gameversions"
LOADER_VER_FILE="$LIST_CACHE_DIR/$SERVER_TYPE-loaderversions"
INSTALLER_VER_FILE="$LIST_CACHE_DIR/$SERVER_TYPE-installerversions"

# The three server version list “arrays”

ServerVersionList=
ServerVersionListStable=
ServerVersionListInstalled=
NumServerVersions=
NumStableServerVersions=
NumInstalledServerVersions=

# Desktop directories

APPS_DIR="$USER_DIR/.local/share/applications"
ICON_THEME_DIR="$USER_DIR/.local/share/icons/hicolor"

# Default option values

DEFAULT_OPTION_JAR_DIR=$JAR_DIR
DEFAULT_OPTION_WORLD_DIR=$WORLD_DIR
DEFAULT_OPTION_BACKUP_DIR=$BACKUP_DIR
DEFAULT_OPTION_JAVA_MEMORY="2G"
DEFAULT_OPTION_TEXT_EDITOR="nano" # Default fallback editor
DEFAULT_OPTION_ARCHIVER="tgz" # Default archiver
DEFAULT_OPTION_AGREED_TO_EULA="false"

# Global option variables

OptionJavaMemory=$DEFAULT_OPTION_JAVA_MEMORY
OptionJarDir=$DEFAULT_OPTION_JAR_DIR
OptionWorldDir=$DEFAULT_OPTION_WORLD_DIR
OptionBackupDir=$DEFAULT_OPTION_BACKUP_DIR
OptionTextEditor=$DEFAULT_OPTION_TEXT_EDITOR
OptionArchiver=$DEFAULT_OPTION_ARCHIVER
OptionAgreedToEULA=$DEFAULT_OPTION_AGREED_TO_EULA

# Option variable keys

JarDirKey="jar-directory"
WorldDirKey="world-directory"
BackupDirKey="backup-directory"
JavaMemoryKey="java-memory"
TextEditorKey="text-editor"
ArchiverKey="archiver"
AgreedToEULAKey="agreed-to-eula"

# Common dialog options

NAVIGATION_DELAY="1" # Seconds of delay after interacting with a dialog
INFO_DELAY="3" # A somewhat longer delay for infobox chains
LONG_DELAY=$(($INFO_DELAY * 2))
DIALOG_COMMON_MIN="--colors --sleep $NAVIGATION_DELAY --stdout"
DIALOG_COMMON="$DIALOG_COMMON_MIN --defaultno --scrollbar"

# Default dialog sizes

MAIN_MENU_SIZE="22 78 22"
INFOBOX_SIZE="6 60"
MESSAGEBOX_SIZE="8 60"
DECISION_BOX_SIZE="9 50"
PROGRAM_BOX_SIZE="-2 -2"
INPUTBOX_SIZE="7 60"
DIR_SELECTOR_SIZE="22 60"

# Dialog return codes

DIALOG_RET_ERROR="-1"
DIALOG_RET_OK="0"
DIALOG_RET_CANCEL="1"
DIALOG_RET_HELP="2"
DIALOG_RET_EXTRA="3"
DIALOG_RET_TIMEOUT="5"
DIALOG_RET_ESC="255"

# Miscellaneous constants

SHEBANG='#!/bin/sh\n'

CONFIG_HEADER="# Generated by $APP_NAME $APP_VER\n"

NOWHERE="/dev/null"

PING_IP="8.8.8.8" # Google DNS
CONNECTION_TIMEOUT="30" # seconds
CONNECTION_RETRIES="2"
USER_AGENT="$APP_NAME $APP_VER$DEV_SUFFIX (curl $(curl --version | head -n 1 | cut -d " " -f 2); $(uname -si); github.com/$MAINTAINER/$APP_NAME)"

CURL_OPTIONS="--connect-timeout $CONNECTION_TIMEOUT --retry $CONNECTION_RETRIES"
CURL_OPTIONS_USER_AGENT="$CURL_OPTIONS --user-agent \"$USER_AGENT\" "
CURL_OPTIONS_FOLLOW="$CURL_OPTIONS -L --max-redirs 2"
CURL_OPTIONS_USER_AGENT_FOLLOW="$CURL_OPTIONS_USER_AGENT -L --max-redirs 2"

ICON_DIMENSIONS="512" # Dimensions of the bundled desktop icon

KICKSTART=$FALSE # Whether the script was kickstarted

DEFAULT_ABBREV_LENGTH="78" # default abbreviation length for text shortener
DEFAULT_ABBREV_LENGTH_MENU="40" # default text abbreviation length in menus

# Custom color scheme for ‘dialog’

UI_COLORS="\n
screen_color = (GREEN,BLACK,ON)\n
\n
shadow_color = (BLACK,BLACK,ON)\n
\n
title_color = (YELLOW,WHITE,ON)\n
\n
item_selected_color = (YELLOW, GREEN, ON)\n
tag_selected_color = (YELLOW,GREEN,ON)\n
button_active_color = (YELLOW,GREEN,ON)\n
\n
button_label_active_color = (WHITE,GREEN,ON)\n
button_key_active_color = (WHITE,GREEN,ON)\n
tag_key_selected_color = (WHITE,GREEN,ON)\n
position_indicator_color = (WHITE,GREEN,ON)\n
\n
button_inactive_color = (YELLOW,WHITE,OFF)\n
button_key_inactive_color = (YELLOW,WHITE,OFF)\n
tag_key_color = (YELLOW,WHITE,OFF)\n
\n
tag_color = (BLACK,WHITE,OFF)\n
\n
button_label_inactive_color = (BLACK,WHITE,ON)\n
uarrow_color = (BLACK,WHITE,ON)\n
darrow_color = (BLACK,WHITE,ON)"

##############
# Procedures #
##############

# Quickly reset/unbork the terminal by sending ESC

resetTerminal () {
  printf "%b" "\033c"
}

# Portable echo

echo () {
  printf "%b\n" "$*"
}

# Colored echo

echoRed () {
  echo "\e[1;31m$@\033[0m"
}

echoGreen () {
  echo "\e[1;32m$@\033[0m"
}

echoBold () {
  echo "\e[1;37m$@\033[0m"
}

# Non-interactive error-and-out message for kickstart.

errorExit () {
  echoRed "$@" 1>&2
  exit $FALSE
}

# Return the name of the OS kernel

getKernel () {
                   kernel=$(uname -s) # POSIX-style
  [ "$kernel" ] || kernel=$(sysctl -n kern.ostype) # Unix-style
  [ "$kernel" ] || kernel=$(sysctl -n kernel.ostype) # Linux-style
  [ "$kernel" ] || return $FALSE

  echo $kernel
}

# Return the machine architecture

getArch () {
                 arch=$(uname -m) # POSIX-style
  [ "$arch" ] || arch=$(sysctl -n kern.arch) # Unix-style
  [ "$arch" ] || arch=$(sysctl -n kernel.arch) # Linux-style
  [ "$arch" ] || return $FALSE
  
  echo $arch
}

# Return the type of graphical session, if any, as specifically as possible

getDesktop () {
  # First check whether we are on a non-graphical tty

  desktop=$XDG_SESSION_TYPE

  if [ "$desktop" = "tty" ]; then
    desktop="TTY"
    echo $desktop
    return $FALSE
  fi

  # Check all eligible environment variables
  
  desktop=$XDG_CURRENT_DESKTOP
  [ "$desktop" ]         || desktop=$DESKTOP_SESSION
  [ "$desktop" ]         || desktop=$XDG_SESSION_TYPE
  [ "$desktop" ]         || desktop=$TERM # This should work on macOS

  # xterm as fallback

  $(echo $desktop | grep -e "^xterm") && desktop="xterm"
  
  if [ ! "$desktop" ]; then
    desktop="unknown DE"
    echo $desktop
    return $FALSE
  fi

  echo $desktop
}

# As the name says. $1 (optional) signifies what Enter will do

waitForEnter () {
  what="continue"
  
  [ "$1" ] && what=$1
  
  echo
  echo "$(echoGreen "Press Enter to $what …")"
  read "enter" 2>&1 > $NOWHERE
  sleep $NAVIGATION_DELAY
}

# Check whether a file exists and is a regular file or symlink

fileExists () {
  [ -f "$1" ] || [ -h "$1" ]
}

# Check whether a file exists and is a regular file

fileExistsRegular () {
  [ -f "$1" ]
}

# Check whether a file exists and is r/w

fileAccessible () {
  [ -r "$1" ] && [ -w "$1" ]
}

# Last modified time of file $1 in epoch seconds

fileLastModified () {
  #echo $(stat -c %Y "$1") # GNUism
  echo $(date -r "$1" +%s)
}

# Check if directory $1 is empty

directoryEmpty () {
  [ -z $(ls -A "$1") ]
}

# File size in 1024 byte units

fileSizeK () {
  du -k $1 | cut -f1
}

# Human-readable file size

fileSizeH () {
  du -h $1 | cut -f1
}

# Seconds since the epoch

now () {
  date +%s
}

# Human-readable time stamp

nowH () {
  date +%Y%m%d%H%M%S
}

# Format dialog text $1 reverse red

textFormatError () {
  echo "\Z1\Zr $* \Zn"
}

# Format dialog text $1 reverse black

textFormatEmphasis () {
  echo "\Z0\Zr $* \Zn"
}

# Convert spaces from stdin to no-break spaces.

spaceToNBSP () {
  sed "s/ / /g"
}

# Convert no-break spaces from stdin to spaces.

NBSPToSpace () {
  sed "s/ / /g"
}

# Enclose the argument(s) in typographic single quotes

TSQ () {
  echo "‘$@’"
}

# Enclose the argument(s) in typographic double quotes

TDQ () {
  echo "“$@”"
}

# Shorten the string $1 to max. $2 characters, including a trailing ellipsis

abbreviateString () {
  maxLength=$2
  [ -z "$maxLength" ] && maxLength=$DEFAULT_ABBREV_LENGTH

  longString=$1
  longStringLength=$(echo $longString | wc -m)
  
  abbrevString=$(printf "%.*s" $maxLength $longString)
  abbrevStringLength=$(echo $abbrevString | wc -m)

  [ "$abbrevStringLength" -lt "$longStringLength" ] && abbrevString="$abbrevString…"
  
  echo $abbrevString
}

# Follow a symlink chain starting with $1, which must be an executable (the
# path portion may be omitted if it is in the search path). If anything is
# given as a second argument, for example "verbose", the output is verbose
# with infoboxes.

followExecutableSymlinks () {
  verbose=$2
  file=$1
  previousFile=

  [ "$verbose" ] && dialogInfo "Resolving symlink chain …" && sleep $NAVIGATION_DELAY
  
  while file=$(readlink $(command -v $file)); do
    [ "$verbose" ] && dialogInfo "Resolving $(textFormatEmphasis $file) …" && sleep $NAVIGATION_DELAY
    previousFile=$file
  done
  
  echo $previousFile
}

# Check whether a command is available in the system.

commandExists () {
  command -v $@ > $NOWHERE
}

# Check whether command $1 is available in the system and optionally recommend
# installing the required package $2.

verifyDependency () {
  errorText=
  cmd=$1; pkg=$2
  
  if ! commandExists $cmd; then

    if [ "$KICKSTART" = "$TRUE" ]; then
      errorText="Dependency error: Command $(TSQ $cmd) is not available!"
      [ "$pkg" ] && errorText="$errorText Try installing the $(TSQ $pkg) package. --Exiting."
      errorExit "$errorText"
    else
      errorText="Command $(TSQ $(textFormatError $cmd)) is not available!"
      [ "$pkg" ] && errorText="$errorText Please install the $(TSQ $(textFormatError $pkg)) package. Exiting."
      dialogMessage "Required dependency missing" "$errorText"
    fi

    exit $FALSE
  fi
}

# Determine the editor to use

detectTextEditor () {
  editor=

  if [ "$EDITOR" ]; then
    dialogInfo "’EDITOR’ environment variable is set …"
    editor=$EDITOR
    sleep $INFO_DELAY
  elif commandExists "editor"; then # On systems with update-alternatives
    target=$(followExecutableSymlinks editor)
    dialogInfo "$(TSQ "editor") symlink is present, pointing to $(TSQ $(textFormatEmphasis $target)) …"
    editor="editor"
    sleep $INFO_DELAY
  elif commandExists "$DEFAULT_OPTION_TEXT_EDITOR"; then
    dialogInfo "Using internal default $TSQ($DEFAULT_OPTION_TEXT_EDITOR) …"
    editor=$DEFAULT_OPTION_TEXT_EDITOR
    sleep $INFO_DELAY
  else
    dialogInfo "$(TSQ $DEFAULT_OPTION_TEXT_EDITOR) not found, falling back to $(TSQ "vi") …"
    editor="vi" # Should be installed just about everywhere
    sleep $INFO_DELAY
  fi
  
  echo $editor
}

# Return the version of the installed default Java runtime

getJavaVersion () {
  java --version | head -n 1
}

# Download and dump to stdout. Typically $1 would be one of the $CURL_OPTIONS*
# constants and $2 the URL to download from

download () {
  curl -s $*
}

# Check whether a server version is installed. $1 is the version as displayed
# in the server lists. $2 (optional) is the server type and defaults to
# “$SERVER_TYPE”

isServerInstalled () {
  serverVersion=$1
  [ -z "$2" ] && serverType=$SERVER_TYPE || serverType=$2
  prefix="$(serverPrefix $serverVersion $serverType)"

  fileExists "$OptionJarDir/$prefix/$prefix.jar" && return $TRUE || return $FALSE
}

# Compare $1 and $2 server version, return true if $1 is newer. $3 (optional)
# is the server type

isServerVersionNewer () {
  ! fileAccessible $GAME_VER_FILE && return $FALSE
  
  serverListJSON=$(cat $GAME_VER_FILE)
  NumServerVersions=$(echo $serverListJSON | jq ". | length")

  lhs=; rhs=
  
  serverCounter="0"

  while [ "$serverCounter" -lt "$NumServerVersions" ]; do
    server=$(echo $serverListJSON | jq -r ".[$serverCounter].version" | spaceToNBSP)

    server=$1 && lhs=$serverCounter
    server=$2 && rhs=$serverCounter

    serverCounter=$(($serverCounter + 1))
  done

  if [ "$lhs" ] && [ "$rhs" ]; then
    [ "$lhs" -gt "$rhs" ] && return $TRUE
  fi
  
  return $FALSE
}

# Get the version of latest server jar, whether stable or not. $1 (optional)
# signifies the server type

getLatestServerVersion () { 
  fileAccessible $GAME_VER_FILE || return $FALSE;
  echo $(cat $GAME_VER_FILE | jq -r ".[0].version")
  return $TRUE
}

# Get the version of latest stable server jar, optionally provide $1 for the
# server type

getLatestStableServerVersion () {
  ! fileAccessible $GAME_VER_FILE && echo "unknown" && return $FALSE
  
  serverListJSON=$(cat $GAME_VER_FILE)
  NumServerVersions=$(echo $serverListJSON | jq ". | length")

  serverCounter="0"

  while [ "$serverCounter" -lt "$NumServerVersions" ]; do
    isStable=$(echo $serverListJSON | jq -r ".[$serverCounter].stable")
    
    if [ "$isStable" = "true" ]; then
      echo $(echo $serverListJSON | jq -r ".[$serverCounter].version" | spaceToNBSP)
      return $TRUE
    fi

    serverCounter=$(($serverCounter + 1))
    
  done
  
  echo "unknown"
  return $FALSE
}

# Return the latest installed server, whether stable or not. A supplied $1
# signifies the server type.

getLatestInstalledServerVersion () {
  serverType=$1

  [ -z "$serverType" ] && serverType=$SERVER_TYPE
  ! fileAccessible $GAME_VER_FILE && echo "unknown" &&‌ return $FALSE
  
  serverListJSON=$(cat $GAME_VER_FILE)
  NumServerVersions=$(echo $serverListJSON | jq ". | length")

  serverCounter="0"

  while [ "$serverCounter" -lt "$NumServerVersions" ]; do
    version=$(echo $serverListJSON | jq -r ".[$serverCounter].version" | spaceToNBSP)
    isServerInstalled $version $serverType && echo $version && return $TRUE

    serverCounter=$(($serverCounter + 1))
  done

  echo "unknown"
  return $FALSE
}

# Check whether we need to update something in the cache. $1 is a single
# filename (to check its modification time), $2 the update interval in seconds

needToCache () {
  file=$1
  interval=$2

  [ ! "$interval" ] && $interval="3600" # default to one hour

  timeLastCaching="0"
  timeNow=$(now)
  timeDiff=
  ret=$FALSE

  if fileExistsRegular $file; then
    timeLastCaching=$(fileLastModified $file)
    timeDiff=$(($timeNow - $timeLastCaching))
    [ "$timeDiff" -ge "$interval" ] && ret=$TRUE
  else # If file does not exist, always cache
    touch $file
    timeLastCaching=$timeNow
    ret=$TRUE
  fi

  return $ret
}

# Get server/loader/installer lists from Fabric Meta and cache them to disk
# (see: https://github.com/FabricMC/fabric-meta)

cacheFabricMeta () {
  dialogInfo "Caching game versions …"

  download "$CURL_OPTIONS_USER_AGENT" "$FABRIC_API_URL/versions/game" > $GAME_VER_FILE
  
  if [ ! -s "$GAME_VER_FILE" ] && fileExists $GAME_VER_FILE; then
    rm -f $GAME_VER_FILE
    dialogMessage "Caching error" "There was a problem updating the game version list! Exiting."
    exit $FALSE
  fi
  
  dialogInfo "Caching loader versions …"
  download "$CURL_OPTIONS_USER_AGENT" "$FABRIC_API_URL/versions/loader" > $LOADER_VER_FILE

  if [ ! -s "$LOADER_VER_FILE" ] && fileExists $LOADER_VER_FILE; then
    rm -f $LOADER_VER_FILE
    dialogMessage "Caching error" "There was a problem updating the loader list! Exiting."
    exit $FALSE
  fi

  dialogInfo "Caching installer versions …"
  download "$CURL_OPTIONS_USER_AGENT" "$FABRIC_API_URL/versions/installer" > $INSTALLER_VER_FILE

  # Check for empty file

  if [ ! -s "$INSTALLER_VER_FILE" ] && fileExists $INSTALLER_VER_FILE; then
    rm -f $INSTALLER_VER_FILE
    dialogMessage "Caching error" "There was a problem updating the installer list! Exiting."
    exit $FALSE
  fi
}

cacheEULA () {
  dialogInfo "Caching Minecraft EULA …"
  download "$CURL_OPTIONS_FOLLOW" "$EULA_URL" | HTMLToText | HTMLEULAFilter > $EULA_FILE
  
  if [ ! "$?" ] && fileExists $EULA_FILE; then
    rm -f $EULA_FILE
    dialogMessage "Caching error" "There was a problem updating the EULA file! Please read the text on $EULA_URL before installing a server with this software."
  fi
}

# Build the server lists from the list caches and the jars directory.
# $1 is the server type.
# The results are stored in the global server lists:
# ServerVersionList, ServerVersionListStable and ServerVersionListInstalled

# TODO: Set this up for different server types (Fabric, vanilla etc.), and
# loop through all types when no argument is given

buildServerLists () {
  if ! fileExists $GAME_VER_FILE; then
    if [ ! "$KICKSTART" = "$TRUE" ]; then
      dialogMessage "Empty list cache" "No version file in the list cache! Try $(textFormatEmphasis "force update list cache") in the main menu."
      return $FALSE
    else # Kickstart cannot continue here because it is non-interactive
      dialogInfo "The list cache is empty! Try $(textFormatEmphasis "force update list cache") in the main menu."
      sleep $LONG_DELAY
      exit $FALSE
    fi
  fi

  ServerVersionList=; ServerVersionListStable=; ServerVersionListInstalled=
  serverVersion=

  serverListJSON=$(cat $GAME_VER_FILE)

  [ -z "$1" ] && serverType=$SERVER_TYPE || serverType=$1
  
  NumServerVersions=$(echo $serverListJSON | jq ". | length")
  NumStableServerVersions="0"
  NumInstalledServerVersions="0"

  dialogInfo "Building server lists for server type $(TSQ $serverType) …"

  serverCounter="0"

  while [ "$serverCounter" -lt "$NumServerVersions" ]; do

    serverVersion=$(echo $serverListJSON | jq -r ".[$serverCounter].version" | spaceToNBSP)
    ServerVersionList="$ServerVersionList$serverVersion "

    isStable=$(echo $serverListJSON | jq -r ".[$serverCounter].stable")
    isServerInstalled "$serverVersion" "$serverType" && isInstalled="true" || isInstalled="false"

    if [ "$isInstalled" = "true" ]; then
      NumInstalledServerVersions=$(($NumInstalledServerVersions + 1))
      ServerVersionListInstalled="$ServerVersionListInstalled$serverVersion "
      installedChar="I"
      $isStable && stableChar="S" || stableChar="u"
      ServerVersionListInstalled="$ServerVersionListInstalled$installedChar$stableChar "
    else
      installedChar="a"
    fi
    
    if [ "$isStable" = "true" ]; then
      NumStableServerVersions=$(($NumStableServerVersions + 1))
      ServerVersionListStable="$ServerVersionListStable$serverVersion "
      stableChar="S"
      ServerVersionListStable="$ServerVersionListStable$installedChar$stableChar "
    else
      stableChar="u"
    fi

    ServerVersionList="$ServerVersionList$installedChar$stableChar "
    serverCounter=$(($serverCounter + 1))
  done
}

# Returns whether the mod with the ID $1 is installed on server $2 of type $3.

isModInstalled () {
  return;
}

# Convert HTML to plain text using sed. From left to right: Remove tags,
# delete blank lines, insert one blank line after each paragraph, delete lines
# with only spaces

HTMLToText () {
  sed -e 's/<[^>]*>//g' -e '/^$/d' -e 's/$/\n/' -e '/^\s*$/d'
}

# Snippet to remove some leftover script code from the Minecraft EULA

HTMLEULAFilter () {
  sed -e '/^\s*$/d' -e '/EULA | Minecraft/,/}(window);/d' -e '/.pageBottom/d'
}

# Make a prefix (e.g. for file or directory names) from $1 (server version)
# and $2 (server type)

serverPrefix () {
  serverVersion="$1"
  [ -z "$2" ] && serverType=$SERVER_TYPE || serverType="$2"

  echo "$serverType-server-$serverVersion"
}

# Show a message box dialog with title $1 and text $2

dialogMessage () {
  dialog $DIALOG_COMMON --title "$1" --msgbox "$2" $MESSAGEBOX_SIZE
}

# Show a simple titleless box with some text

dialogInfo () {
  dialog $DIALOG_COMMON --infobox "$*" $INFOBOX_SIZE
}

# Takes a command’s output and continually displays it in a box with text $1
# until finished, then adds an OK button

dialogProgram () {
  dialog $DIALOG_COMMON --programbox "$1" $PROGRAM_BOX_SIZE
}

# Yes/No dialog with title $1 and text $2

dialogYesNo () {
  dialog $DIALOG_COMMON --title "$1" --yesno "$2" $DECISION_BOX_SIZE
}

# Ok/Cancel dialog with title $1 and text $2

dialogOkCancel () {
  dialog $DIALOG_COMMON --yes-label "Ok" --no-label "Cancel" --title "$1" --yesno "$2" $DECISION_BOX_SIZE
}

# Input dialog with title $1, text $2 and (optional) init $3

dialogInput () {
  dialog $DIALOG_COMMON_MIN --title "$1" --inputbox "$2" $INPUTBOX_SIZE "$3"
}

# Directory selection dialog with title $1 and starting directory $2

dialogDirSelect (){
  dialog $DIALOG_COMMON --title "$1" --dselect "$2" $DIR_SELECTOR_SIZE
}

# Progress bar with title $1, text $2 and (optional) initial percentage $3

dialogProgress () {
  dialog $DIALOG_COMMON --title "$1" --gauge "$2" $MESSAGEBOX_SIZE "$3"
}

# Show the server list. $1 = "stable" for stable servers only, "installed" for
# installed ones, otherwise "all".
# $2 (optional) is the server type, for example "fabric"

menuServerList () {
  [ ! "$ServerVersionList" ] && dialogMessage "Server version list empty" "The list of server versions is null! Try $(textFormatEmphasis "force update list cache") in the main menu." && return $FALSE

  serverSubset=$1
  [ "$2" ] && serverType="$2" || serverType=$SERVER_TYPE
  
  case $serverSubset in
    installed)
      menuList=$ServerVersionListInstalled
      howMany=$NumInstalledServerVersions
      if [ "$howMany" = "0" ]; then
        dialogMessage "No servers" "You do not have any servers installed! Please pick one from the $(TSQ "stable") or $(TSQ "all") list."
        return $FALSE
      fi ;;
    stable)
      menuList=$ServerVersionListStable
      howMany=$NumStableServerVersions ;;
    all)
      menuList=$ServerVersionList
      howMany=$NumServerVersions ;;
    *)
      return $FALSE;
  esac
  
  while true; do
    choice=$(
    dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "Server selection ($serverSubset)" --menu \
  "$howMany $serverType server(s) found.\n\n \
  I = installed, a = available, S = stable, u = unstable" \
  $MAIN_MENU_SIZE \
    $menuList
    )

    if [ "$choice" ]; then
      isServerInstalled "$choice" "$serverType" && menuInstalledServer $choice || menuAvailableServer $choice
    else
      break
    fi

  done
}

# Menu for installed servers. $1 is the server version, $2 (optional) the
# server type.

menuInstalledServer () {
  serverVersion=$1
  [ "$2" ] && serverType="$2" || serverType=$SERVER_TYPE
  
  serverPropFile="$OptionJarDir/$(serverPrefix $serverVersion $serverType)/server.properties"

  while true; do
    world=$(readConfigKey $serverPropFile "level-name")

    choice=$(
    dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "Installed server" --menu \
  "Manage the $(TSQ $serverVersion $serverType) server installation and the currently attached world $(TSQ $world)." \
  $MAIN_MENU_SIZE \
    "s" "Start server" \
    "w" "Select world ($(textFormatEmphasis $world))" \
    "m" "Manage mods" \
    "p" "Edit $(textFormatEmphasis "server.properties")" \
    "b" "Backup" \
    "o" "$(textFormatError "Optimize world")" \
    "g" "$(textFormatError "Purge world")" \
    "u" "Uninstall"
    )

    case $choice in
      s)
        runServer $serverVersion $serverType ;;
      m)
        menuAvailableMods $serverVersion $serverType ;;
      w)      
        w=$(menuSelectWorld $world $serverVersion $serverType)
        [ "$w" ] && writeConfigKey $serverPropFile "level-name" $w ;;
      p)
        $OptionTextEditor $serverPropFile ;;
      b)      
        backup $serverVersion $serverType ;;
      o)
        optimizeWorld $world $serverVersion $serverType ;;
      g)
        purgeWorld $world ;;
      u)
        uninstallServer $serverVersion $serverType ;;
      *)
        break ;;
    esac

  done
}

# Menu for servers that are not installed

menuAvailableServer () {
  serverVersion=$1
  [ "$2" ] && serverType="$2" || serverType=$SERVER_TYPE
  
  while true; do
    choice=$(
    dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "Available server" --menu \
  "Options for downloadable servers." \
  $MAIN_MENU_SIZE \
    "i" "Download and install $serverVersion ($serverType)"
    )

    case $choice in
      i)
        downloadServer "$1" "$2" && break ;;
      *)
        break ;;
    esac
  done
}

# The front-end menu to the mod menus

menuModManagement () {
  serverVersion=$1
  [ "$2" ] && serverType="$2" || serverType=$SERVER_TYPE
  
  while true; do
    choice=$(
    dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "Mod manager for $1 ($2)" --menu \
  "What do you want to do?" \
  $MAIN_MENU_SIZE \
    "m" "Manage installed mods"
    "b" "Browse available mods"
    "u" "Update all installed mods"
    )

    case $choice in
      m)
        break ;;
      b)
        menuAvailableMods "$1" "$2" && break ;;
      u)
        break ;;
      *)
        break ;;
    esac
  done
}

# Show a menu of installed mods for server version $1 and server type $2

menuInstalledMods () {
  return;
}

# Load and present a list of supported mods for server version $1 and server
# type $2

menuAvailableMods () {
  serverVersion=$1
  [ "$2" ] && serverType="$2" || serverType=$SERVER_TYPE

  modCategory="optimization"
  modSorting="follows"
  modsPerPage="25"
  listOffset="0"

  mustCache=$TRUE

  while true; do

    if [ $mustCache = $TRUE ]; then

      dialogInfo "Caching $serverType mod(s) for $serverVersion …"

      # Test query for reqbin
      #https://api.modrinth.com/v2/search?facets=[["project_type:mod"],["versions:1.21.8"],["categories:fabric"],["categories:optimization"],["server_side:required","server_side:optional"],["client_side:optional","client_side:unsupported"]]&index=follows&offset=10&limit=10

      # URL encoded query mask

      queryString="$MODRINTH_API_URL/search\
?facets=\
%5B%5B%22project_type%3Amod%22%5D%2C\
%5B%22versions%3A$serverVersion%22%5D%2C\
%5B%22categories%3A$serverType%22%5D%2C\
%5B%22categories%3A$modCategory%22%5D%2C\
%5B%22server_side%3Arequired%22%2C\
%22server_side%3Aoptional%22%5D%2C\
%5B%22client_side%3Aoptional%22%2C\
%22client_side%3Aunsupported%22%5D%5D\
&index=$modSorting\
&offset=$listOffset\
&limit=$modsPerPage"

      modJSON=$(download $CURL_OPTIONS_USER_AGENT -X GET $queryString)
      numMods=$(echo $modJSON | jq -r ".total_hits")

      error=$(echo $modJSON | jq -r ".error")

      [ "$error" != "null" ] && dialogMessage "Mod caching error" "The mod server returned an error!\n\n$(textFormatError $error)" && return $FALSE

      [ "$numMods" -eq "0" ] && dialogMessage "Mod search error" "No mods matching the criteria were found:\n\n$(textFormatError "Version: $serverVersion, category: $serverType, category: $modCategory")" && return $FALSE

      # Craft the mod list

      modList=
      #modListWidth="78"
      modCounter="0";

      [ "$listOffset" -gt "0" ] && modList="$modList< Previous page "
      
      while [ $modCounter -lt $modsPerPage ]; do
        modID=$(echo $modJSON | jq -r ".hits[$modCounter].project_id")
        modTitle=$(echo $modJSON | jq -r ".hits[$modCounter].title" | spaceToNBSP)
        modDescription=$(echo $modJSON | jq -r ".hits[$modCounter].description" | spaceToNBSP)

        [ "$modTitle" = "null" ] && break;

        modList="$modList$modID $(textFormatEmphasis $modTitle)– $modDescription "
        #modList="$modList$modID $(abbreviateString "$(textFormatEmphasis $modTitle)– $modDescription" "$modListWidth") "
        
        modCounter=$(($modCounter + 1))
      done

      [ "$listOffset" -lt "$(($numMods - ($modCounter + 1)))" ] && modList="$modList> Next page "

      mustCache=$FALSE

    fi

    choice=$(
      dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "Server mods" --menu \
      "Showing $(($listOffset + 1))-$(($listOffset + $modCounter)) of $numMods $serverType server $modCategory mod(s)." \
      $MAIN_MENU_SIZE \
      $modList
      )
      
      if [ "$choice" ]; then
        case $choice in
          \<)
            [ "$listOffset" -ge "$modsPerPage" ] && listOffset=$(($listOffset - $modsPerPage)) && mustCache=$TRUE ;;
          \>)
            [ "$listOffset" -lt "$numMods" ] && listOffset=$(($listOffset + $modsPerPage)) && mustCache=$TRUE ;;
          ????????)
            dialogMessage "Mod ID" "$choice" ;;
        esac
      else
        break
      fi

    done
}

# Show details about the mod with ID $1 relating to the server $2 of type $3.

menuModDetails () {
  return
}

# World selector for installed servers. $1 is the name of the currently used
# world; $2 and (optionally) $3 are server version and type.

menuSelectWorld () {
  worldName=$1
  serverVersion=$2
  [ "$3" ] && serverType="$3" || serverType=$SERVER_TYPE

  worlds=$(ls -t1 $OptionWorldDir)
  worldList=$newWorld
  
  worldCounter="0"
  
  for world in $worlds; do
    if [ -d "$OptionWorldDir/$world" ]; then
      [ "$world" = "$worldName" ] && worldChar="U" || worldChar=" "
      worldList="$worldList$world $worldChar "
      worldCounter=$(($worldCounter + 1))
    fi
  done

  while true; do

  [ ! "$worldCounter" ] && dialogMessage "Error" "No worlds found in $(textFormatEmphasis $OptionWorldDir)!" && return $FALSE

  choice=$(
    dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "World selection" --menu \
  "$worldCounter world(s) found. Select one to use with the $serverVersion ($serverType) server installation. The currently used world is indicated by $(TSQ $(textFormatEmphasis "U"))." \
  $MAIN_MENU_SIZE \
  $worldList
    )

    if [ -z "$choice" ]; then
      return $FALSE
    else
      echo $choice
      return $TRUE
    fi
    
  done
}

# Global options menu

menuGlobalOptions () {
  while true; do
    choice=$(
    dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "Global options" --menu \
  "Global and default options." \
  $MAIN_MENU_SIZE \
    "m" "Java memory" \
    "j" "Server jar root folder ($(textFormatEmphasis $(abbreviateString $OptionJarDir $DEFAULT_ABBREV_LENGTH_MENU)))" \
    "w" "World root folder ($(textFormatEmphasis $(abbreviateString $OptionWorldDir $DEFAULT_ABBREV_LENGTH_MENU)))" \
    "b" "Backup folder ($(textFormatEmphasis $(abbreviateString $OptionBackupDir $DEFAULT_ABBREV_LENGTH_MENU)))" \
    "e" "Default text editor ($(textFormatEmphasis $(abbreviateString $OptionTextEditor $DEFAULT_ABBREV_LENGTH_MENU)))" \
    "a" "Default archiver ($(textFormatEmphasis $(abbreviateString $OptionArchiver $DEFAULT_ABBREV_LENGTH_MENU)))" \
    "i" "Install $APP_NAME" \
    "u" "Uninstall $APP_NAME" \
    "g" "Agree to the Minecraft EULA" \
    "r" "Reset to default settings"
    )

    case $choice in
      m)
        optionUIJavaMemory ;;
      j)
        optionUIJarFolder ;;
      w)
        optionUIWorldFolder ;;
      b)
        optionUIBackupFolder ;;
      e)
        optionUITextEditor ;;
      a)
        optionUIArchiver ;;
      i)
        installScript ;;
      u)
        uninstallScript ;;
      g)
        optionUIAgreeToEULA ;;
      r)
        dialogYesNo "Options reset" "Revert all global settings to their defaults?" && factoryReset ;;
      *)
        break ;;
    esac

  done
}

# The main menu.

menuMain () {
  # Main menu loop

  while true; do
    choice=$(
    dialog $DIALOG_COMMON --no-cancel --erase-on-exit --title "Main menu" --menu \
  "Welcome to $APP_NAME – $APP_DESC\n\n \
  Launcher version: $APP_VER on $(getDesktop)/$(getKernel) $(getArch)\n \
  Java version: $(getJavaVersion)\n \
  Latest server jar: $(getLatestServerVersion), stable: $(getLatestStableServerVersion), installed: $(getLatestInstalledServerVersion)\n" \
  $MAIN_MENU_SIZE \
      "r" "Run latest stable server" \
      "i" "Installed servers" \
      "s" "Available servers (stable)" \
      "a" "Available servers (all)" \
      "u" "Force update list cache" \
      "o" "Global options" \
      "x" "Exit $APP_NAME"
      )
    
    case $choice in
      r)
        instantServer ;;
      i)
        menuServerList "installed" ;;
      s)
        menuServerList "stable" ;;
      a)
        menuServerList "all" ;;
      u)
        onlineWarning "Cannot update the list cache without an internet connection." && cacheFabricMeta
        buildServerLists ;;
      o)
        menuGlobalOptions ;;
      *)
        break ;;
    esac
  done

  unInit
}

# Configuration UI for Java memory

optionUIJavaMemory () {
  value=$(dialogInput "Java Memory" ‌"Default amount of RAM for servers (recommended 2G-16G):" $OptionJavaMemory)

  if [ "$value" ]; then
    OptionJavaMemory=$value
    saveConfig
  fi
}

# Input box for the server jar directory

optionUIJarFolder () {
  while true; do
    
    dir=$(dialogInput "Server jar directory" "Root directory for the server jars:" $OptionJarDir)

    if [ "$dir" ] && [ -d "$dir" ]; then # Directory does exist
      OptionJarDir=$dir
      saveConfig
      break
    elif [ "$dir" ] && [ ! -d "$dir" ]; then # Directory does not exist

      if dialogYesNo "Invalid path" "The directory $(textFormatEmphasis $dir) does not exist, create it?"; then

        if mkdir -p $dir; then
          OptionJarDir=$dir
          saveConfig
          dialogMessage "Success" "The directory $(textFormatEmphasis $dir) has been created."
          break
        else
          dialogMessage "Error" "The directory $(textFormatEmphasis $dir) could not be created."
        fi
      fi
      
    elif [ -z "$dir" ]; then
      break
    fi
    
  done
}

# Input box for the world directory

optionUIWorldFolder () {
  while true; do
    
    dir=$(dialogInput "World directory" "Root directory for the worlds:" $OptionWorldDir)

    if [ "$dir" ] && [ -d "$dir" ]; then # Directory does exist
      OptionWorldDir=$dir
      saveConfig
      break
    elif [ "$dir" ] && [ ! -d "$dir" ]; then # Directory does not exist

      if dialogYesNo "Invalid path" "The directory $(textFormatEmphasis $dir) does not exist, create it?"; then

        if mkdir -p $dir; then
          OptionWorldDir=$dir
          saveConfig
          dialogMessage "Success" "The directory $(textFormatEmphasis $dir) has been created."
          break
        else
          dialogMessage "Error" "The directory $(textFormatEmphasis $dir) could not be created."
        fi
      fi
      
    elif [ -z "$dir" ]; then
      break
    fi
    
  done
}

# Input box for the backup directory

optionUIBackupFolder () {
  while true; do
    
    dir=$(dialogInput "Backup directory" "Root directory for backups:" $OptionBackupDir)

    if [ "$dir" ] && [ -d "$dir" ]; then # Directory does exist
      OptionBackupDir=$dir
      saveConfig
      break
    elif [ "$dir" ] && [ ! -d "$dir" ]; then # Directory does not exist

      if dialogYesNo "Invalid path" "The directory $(textFormatEmphasis $dir) does not exist, create it?"; then

        if mkdir -p $dir; then
          OptionBackupDir=$dir
          saveConfig
          dialogMessage "Success" "The directory $(textFormatEmphasis $dir) has been created."
          break
        else
          dialogMessage "Error" "The directory $(textFormatEmphasis $dir) could not be created."
        fi
      fi
      
    elif [ -z "$dir" ]; then
      break
    fi
    
  done
}

# Input box for the text editor to use

optionUITextEditor () {
  editor=
  
  dialogYesNo "Editor detection" "Would you like to autodetect the editor?" && editor=$(detectTextEditor)
  [ "$editor" ] || editor=$OptionTextEditor

  while true; do
    editor=$(dialogInput "Text editor" "Text editor to use:" $editor)

    if [ "$editor" ]; then
      OptionTextEditor=$editor
      saveConfig
      break
    else
      break
    fi

  done

  echo $editor
}

optionUIArchiver () {
  installed="*"
  
  tgzInstalled=
  zipInstalled=
  sevenZipInstalled=

  commandExists "tar" && commandExists "gzip" && tgzInstalled=$installed
  commandExists "zip" && zipInstalled=$installed
  commandExists "7z" || commandExists "7za" || commandExists "7zr" && sevenZipInstalled=$installed

  while true; do
    choice=$(
    dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "Archiver for backups" --menu \
  "Archiver to use for backups; currently $(textFormatEmphasis $OptionArchiver). $(textFormatEmphasis "*") denotes that the appropriate binaries are installed." \
  $MAIN_MENU_SIZE \
    "t" "Gzipped tar (.tgz) $tgzInstalled" \
    "z" "Zip (.zip) $zipInstalled" \
    "7" "7-Zip (.7z) $sevenZipInstalled"
    )

    case $choice in
      t)
        OptionArchiver="tgz"
        break ;;
      z)
        OptionArchiver="zip"
        break ;;
      7)
        OptionArchiver="7z"
        break ;;
      *)
        return $FALSE ;;
    esac

  done

  dialogMessage "Archiver set" "Default archiver has been set to $(textFormatEmphasis $OptionArchiver)."
}

# Ask the user to agree with the Minecraft EULA

optionUIAgreeToEULA () {
  agreed=$OptionAgreedToEULA
  
  if [ $agreed = "true" ]; then
    dialogMessage "EULA" "You already agreed to the Minecraft EULA."
  else
    if dialogYesNo "EULA" "Do you agree to the Minecraft EULA?\n$EULA_URL"; then
      OptionAgreedToEULA="true"
      dialogMessage "EULA" "Agreement acknowledged. You can now start servers."
    else
      dialogMessage "EULA" "You need to agree to the Minecraft EULA before you can start a server."
    fi
  fi
  
  writeConfigKey $CONFIG_FILE $AgreedToEULAKey $OptionAgreedToEULA
}

# Install the script file to the local bin directory. Optionally also install
# a desktop entry

installScript () {
  # Check if we are running an installed version
  [ "$SCRIPT_DIR" = "$BIN_DIR" ] && dialogMessage "Path error" "The $APP_NAME script is already installed. Please uninstall it first." && return $FALSE
  
  dialogYesNo "$APP_NAME installation" "Install the $(textFormatEmphasis $SCRIPT_NAME) script to $(textFormatEmphasis $BIN_DIR)?" || return
  
  if [ ! $(echo "$PATH" | grep "$BIN_DIR") ]; then
    dialogYesNo "Path error" "$(textFormatEmphasis $BIN_DIR) is not in your PATH variable! Install anyway?" || return $FALSE
  fi

  dialogInfo "Installing the $APP_NAME script …"
  
  cp -fp $0 $BIN_DIR
  
  dialogInfo "Installing the documentation …"

  mkdir -p $LOCAL_DIR
  cp -f $README_FILE $LICENSE_FILE $LOCAL_DIR
  
  dialogMessage "Installation successful" "Script and documentation have been installed. You can now start $APP_NAME by typing $(textFormatEmphasis $SCRIPT_NAME) anywhere."

  # Optionally install a desktop entry if desktop-file-utils is installed
  
  # Check for the desktop assets under the script directory and the current directory

  desktopAssetsDir="$SCRIPT_DIR/desktop"
  [ ! -d "$desktopAssetsDir" ] && desktopAssetsDir="$(pwd)/desktop"
  [ ! -d "$desktopAssetsDir" ] && return
  
  if fileExistsRegular "$desktopAssetsDir/com.$MAINTAINER.$APP_NAME.desktop" &&
     fileExistsRegular "$desktopAssetsDir/$SCRIPT_NAME.svg" &&
     fileExistsRegular "$desktopAssetsDir/$SCRIPT_NAME.png"&&
     commandExists "desktop-file-install"; then

      if dialogYesNo "Desktop entry" "Do you also want to install a desktop icon and menu entry?"; then
        dialogInfo "Installing desktop file and icons …"

        mkdir -p $APPS_DIR "$ICON_THEME_DIR/scalable" $ICON_THEME_DIR/$ICON_DIMENSIONS"x"$ICON_DIMENSIONS
        cp -f "$desktopAssetsDir/$SCRIPT_NAME.svg" "$ICON_THEME_DIR/scalable/apps"
        cp -f "$desktopAssetsDir/$SCRIPT_NAME.png" $ICON_THEME_DIR/$ICON_DIMENSIONS"x"$ICON_DIMENSIONS"/apps"
        desktop-file-install --dir="$APPS_DIR" "$desktopAssetsDir/com.$MAINTAINER.$APP_NAME.desktop"
        
        dialogMessage "Installation successful" "The desktop assets have been installed."
      fi

  else
    return
  fi
}

# Remove the installed script and desktop entries from the system

uninstallScript () {
  if ! fileExists "$BIN_DIR/$SCRIPT_NAME"; then
    dialogMessage "No installation found" "The script is not installed."
    return
  fi

  dialogYesNo "Uninstall $APP_NAME" "Remove the $APP_NAME installation from your system?" || return

  rm -f "$ICON_THEME_DIR/scalable/$SCRIPT_NAME.svg"
  rm -f "$ICON_THEME_DIR/$ICON_DIMENSIONS"x"$ICON_DIMENSIONS/$SCRIPT_NAME.png"
  rm -f "$APPS_DIR/com.$MAINTAINER.$APP_NAME.desktop"
  
  rm -f "$LOCAL_DIR/$README_FILE" "$LOCAL_DIR/$LICENSE_FILE"

  rm -f "$BIN_DIR/$SCRIPT_NAME"

  commandExists update-desktop-database && update-desktop-database

  if directoryEmpty $LOCAL_DIR; then
    rmdir $LOCAL_DIR
  else
    dialogMessage "Leftover data" "There is still some data, possibly server jars or worlds, left in $(textFormatEmphasis $LOCAL_DIR). You should look over those manually."
  fi

  dialogMessage "Uninstall successful" "$APP_NAME has been removed."
}

# Load the global settings from the configuration file

loadConfig () {
  OptionJarDir=$(readConfigKey $CONFIG_FILE $JarDirKey $DEFAULT_OPTION_JAR_DIR)
  OptionWorldDir=$(readConfigKey $CONFIG_FILE $WorldDirKey $DEFAULT_OPTION_WORLD_DIR)
  OptionBackupDir=$(readConfigKey $CONFIG_FILE $BackupDirKey $DEFAULT_OPTION_BACKUP_DIR)
  OptionJavaMemory=$(readConfigKey $CONFIG_FILE $JavaMemoryKey $DEFAULT_OPTION_JAVA_MEMORY)
  OptionTextEditor=$(readConfigKey $CONFIG_FILE $TextEditorKey $DEFAULT_OPTION_TEXT_EDITOR)
  OptionArchiver=$(readConfigKey $CONFIG_FILE $ArchiverKey $DEFAULT_OPTION_ARCHIVER)
  OptionAgreedToEULA=$(readConfigKey $CONFIG_FILE $AgreedToEULAKey $DEFAULT_OPTION_AGREED_TO_EULA)
}

# Saves the configuration file

saveConfig () {
  echo $CONFIG_HEADER > $CONFIG_FILE

  writeConfigKey $CONFIG_FILE $JarDirKey $OptionJarDir
  writeConfigKey $CONFIG_FILE $WorldDirKey $OptionWorldDir
  writeConfigKey $CONFIG_FILE $BackupDirKey $OptionBackupDir
  writeConfigKey $CONFIG_FILE $JavaMemoryKey $OptionJavaMemory
  writeConfigKey $CONFIG_FILE $TextEditorKey $OptionTextEditor
  writeConfigKey $CONFIG_FILE $ArchiverKey $OptionArchiver
  writeConfigKey $CONFIG_FILE $AgreedToEULAKey $OptionAgreedToEULA
}

# Write the config file with the defaults

writeDefaultConfig () {
  dialogMessage "Initial configuration" "No configuration file was found; creating one in $(textFormatEmphasis $CONFIG_DIR)."

  echo $CONFIG_HEADER > $CONFIG_FILE

  writeConfigKey $CONFIG_FILE $JarDirKey $DEFAULT_OPTION_JAR_DIR
  writeConfigKey $CONFIG_FILE $WorldDirKey $DEFAULT_OPTION_WORLD_DIR
  writeConfigKey $CONFIG_FILE $BackupDirKey $DEFAULT_OPTION_BACKUP_DIR
  writeConfigKey $CONFIG_FILE $JavaMemoryKey $DEFAULT_OPTION_JAVA_MEMORY
  writeConfigKey $CONFIG_FILE $TextEditorKey $DEFAULT_OPTION_TEXT_EDITOR
  writeConfigKey $CONFIG_FILE $ArchiverKey $DEFAULT_OPTION_ARCHIVER
  writeConfigKey $CONFIG_FILE $AgreedToEULAKey $DEFAULT_OPTION_AGREED_TO_EULA
}

factoryReset () {
  OptionJarDir=$DEFAULT_OPTION_JAR_DIR
  OptionWorldDir=$DEFAULT_OPTION_WORLD_DIR
  OptionBackupDir=$DEFAULT_OPTION_BACKUP_DIR
  OptionJavaMemory=$DEFAULT_OPTION_JAVA_MEMORY
  OptionTextEditor=$DEFAULT_OPTION_TEXT_EDITOR
  OptionArchiver=$DEFAULT_OPTION_ARCHIVER
  OptionAgreedToEULA=$DEFAULT_OPTION_AGREED_TO_EULA

  saveConfig
  dialogMessage "Reset" "All global options have been reset."
}

# Read the value of a key=value pair from a configuration file.
# $1=file, $2=key, $3=default value (optional)

readConfigKey () {
  file=$1; key=$2; defaultValue=$3; value=

  ! fileAccessible $file && touch $file # Make sure the file exists

  value=$(grep -e "^$key=.*" $file | sed -e 's/ //g' | cut -d "=" -f 2)
  [ "$value" ] || value=$defaultValue

  echo $value
}

# Write a key=value pair to a configuration file.
# $1=file, $2=key, $3=value

writeConfigKey () {
  file=$1; key=$2; value=$3

  touch $file
  
  if fileAccessible $file; then # The file is there and we can read and write
    # Many non-GNU seds cannot modify data in-place, hence we need a tempfile

    #sed -e '/^#/!s/ //g' $file > $TMP_FILE # Sanitize the file and copy to /tmp
    cp -f $file $TMP_FILE

    if grep -e "^$key=.*" $TMP_FILE; then # Is the key in the file?
    
      if grep -e "^$key=$value$" $TMP_FILE; then
        return # Same value, outta here
      else
        #sed -e "s/^$key=.*/$key=$value/g" $file > $TMP_FILE # Update value
        sed -e "s/\($key *= *\).*/\1$value/g" $file > $TMP_FILE
      fi 

    else
      echo "$key=$value" >> $TMP_FILE # Key-value pair not present, append
    fi

    mv -f $TMP_FILE $file # Update the file with the changes
  
  else # File not accessible or nonexistent
    if [ "$KICKSTART" = "$TRUE" ]; then
      errorExit "ERROR: No write access to configuration file!"
    else
      dialogMessage "Filesystem error" "Cannot access the configuration file! Check directory permissions for $(dirname $file)."
      exit $FALSE
    fi
  fi
}

# Force upgrade world $1 and erase the cache. Do this using server version $2
# of (optionally) type $3.

optimizeWorld () {
  world=$1
  
  serverVersion=$2
  serverType=$3
  [ "$3" ] && serverType="$3" || serverType=$SERVER_TYPE

  [ -z "$world" ] && dialogMessage "Error" "World folder of $(TSQ $(textFormatEmphasis $world))’not found!"
  
  dialogYesNo "Optimize $world" "Upgrade to the newest world format? This will force recalculation of world data on the next server invocation, and the world may become $(textFormatError "incompatible") with older server versions." || return

  dialogInfo "Starting the server … type $(TSQ "/stop") in the console for shutdown."
  sleep $LONG_DELAY
  
  serverDir="$OptionJarDir/$(serverPrefix $serverVersion $serverType)"
  cd $serverDir

  resetTerminal

  java -Xmx"$OptionJavaMemory" -jar "$(serverPrefix $serverVersion $serverType).jar" --universe $OptionWorldDir --forceUpgrade --eraseCache --nogui
  
  echoBold
  echoBold "Done!"
  echoBold
  
  waitForEnter "continue"
  
  resetTerminal
  
  cd $SCRIPT_DIR
}

# Purge the contents of world $1, optionally deleting it entirely by removing
# the folder.

purgeWorld () {
  world=$1

  [ ! -d "$OptionWorldDir/$world" ] && dialogMessage "World does not exist" "There is no world data to erase. Start the server to recreate the world, or change it to another world." && return

  dialogOkCancel "Confirm world purge" "This will erase all contents of the world $(TSQ $(textFormatEmphasis $world)), including $(textFormatError "everything you built")!" || return

  dialogInfo "Deleting world contents …"
  
  rm -rf "$OptionWorldDir/$world" > $NOWHERE

  dialogMessage "World erased" "The world $(TSQ $(textFormatEmphasis $world)) has been purged. If you don’t change the server to another world, it will be recreated on its next invocation."

  resetTerminal
}

# Backup server version $1 of (optionally) type $2 and/or its attached world
# to time-stamped archives

backup () {
  serverVersion=$1
  [ "$2" ] && serverType="$2" || serverType=$SERVER_TYPE

  serverPropFile="$OptionJarDir/$(serverPrefix $serverVersion $serverType)/server.properties"
  world=$(readConfigKey $serverPropFile "level-name")

  archiveCommand=
  commandLine=

  while true; do

    case $OptionArchiver in
      tgz)
        archiveCommand="tar -cvzf" ;;
      zip)
        archiveCommand="zip -r" ;;
      7z)
        archiveCommand="7zr a -r" ;;
      *)
        dialogMessage "Settings error" "Invalid setting for archiver! Please select one in the global options."
        return $FALSE ;;
    esac

    choice=$(
    dialog $DIALOG_COMMON --cancel-label "Back" --default-button "ok" --title "Backup options" --menu \
  "What should I do?" \
  $MAIN_MENU_SIZE \
    "s" "Backup server ($(textFormatEmphasis $serverVersion))" \
    "w" "Backup world ($(textFormatEmphasis $world))" \
    "a" "Select archiver ($(textFormatEmphasis $(abbreviateString $OptionArchiver $DEFAULT_ABBREV_LENGTH_MENU)))" \
    "p" "Set backup path ($(textFormatEmphasis $(abbreviateString $OptionBackupDir $DEFAULT_ABBREV_LENGTH_MENU)))" \
    )

    case $choice in
      s)
        cd $OptionJarDir

        dialogYesNo "Server backup" "Perform the server backup to $(textFormatEmphasis $OptionBackupDir) in $(textFormatEmphasis $OptionArchiver) format?" || continue
        backupFileName="$(serverPrefix $serverVersion $serverType)-$(nowH).$OptionArchiver"
        commandLine="$archiveCommand $backupFileName $(serverPrefix $serverVersion $serverType)/"

        resetTerminal
        echoBold "Creating server backup archive …"
        echoBold

        $commandLine

        [ "$?" -ne "0" ] && dialogMessage "Error" "Could not create the backup archive: error $?!" && break

        echoBold
        echoBold "Moving the backup archive to the backup location …"
        echoBold

        mv -fv $backupFileName $OptionBackupDir

        [ "$?" -ne "0" ] && dialogMessage "Error" "Could not move the backup archive: error $?!" && break

        echoBold
        echoBold "Done. File size: $(fileSizeH "$OptionBackupDir/$backupFileName")"
        echoBold

        waitForEnter "continue"
        resetTerminal

        dialogMessage "Backup completed" "The server $(TSQ "$serverVersion" "($serverType)") has been backed up to $OptionBackupDir/$(textFormatEmphasis $backupFileName)." ;;
      w)
        cd $OptionWorldDir

        dialogYesNo "World backup" "Perform a world backup to $(textFormatEmphasis $OptionBackupDir) in $(textFormatEmphasis $OptionArchiver) format?" || continue

        backupFileName="world-$world-$(nowH).$OptionArchiver"
        commandLine="$archiveCommand $backupFileName $world/"

        resetTerminal
        echoBold "Creating world backup archive …"
        echoBold

        $commandLine

        [ "$?" -ne "0" ] && dialogMessage "Error" "Could not create the backup archive: error $?!" && break

        echoBold
        echoBold "Moving the backup archive to the backup location …"
        echoBold

        mv -fv $backupFileName $OptionBackupDir

        [ "$?" -ne "0" ] && dialogMessage "Error" "Could not move the backup archive: error $?!" && break

        echoBold
        echoBold "Done. File size: $(fileSizeH "$OptionBackupDir/$backupFileName")"
        echoBold

        waitForEnter "continue"
        resetTerminal

        dialogMessage "Backup completed" "The world $(TSQ "$world") has been backed up to $OptionBackupDir/$(textFormatEmphasis $backupFileName)." ;;
      a)
        optionUIArchiver ;;
      p)
        optionUIBackupFolder ;;
      *)
        break ;;
    esac

  done

  cd $SCRIPT_DIR
  return;
}

# Return true if we have internet connectivity

online () {
  ping -c 1 $PING_IP | grep -q "0%" > $NOWHERE
}

# A small wrapper around the ‘online’ function that displays $* as a message.

onlineWarning () {
  online && return $TRUE
  
  dialogMessage "No internet connectivity" "$*"
  
  return $FALSE
}

# Download and initialize the server of version $1 and (optionally) type $2

downloadServer () {
  matchFile="$LIST_CACHE_DIR/$SERVER_TYPE-loadermatch"

  serverVersion="$1"
  anyLoader=; stableLoader=
  installer=

  serverType=
  loaderJSON=

  [ -z "$2" ] && serverType=$SERVER_TYPE || serverType="$2"
  
  dialogInfo "Finding the best loader for $serverVersion ($serverType) …"

  download $CURL_OPTIONS_USER_AGENT "$FABRIC_API_URL/versions/loader/$serverVersion" > $matchFile

  loaderJSON=$(cat $matchFile)
  if [ ! "$loaderJSON" ]; then
    [ "$KICKSTART" = "$FALSE" ] && dialogMessage "Transmission error" "The loader match data could not be obtained."
    return $FALSE
  fi

  numLoaderVersions=$(echo $loaderJSON | jq ". | length")

  # Default to the newest loader whether stable or unstable
  
  anyLoader=$(echo $loaderJSON | jq -r ".[0].loader.version")

  # Then look for the newest stable loader

  stableLoader=; l="0"
  
  while [ "$l" -lt "$numLoaderVersions" ]; do
  
    stableLoader=$(echo $loaderJSON | jq -r ".[$l].loader.version")
    isStable=$(echo $loaderJSON | jq -r ".[$l].loader.stable")
  
    [ "$isStable" = "true" ] && break;
    
    l=$(($l + 1))
  done
  
  if [ "$anyLoader" = "$stableLoader" ]; then
    dialogInfo "Finding the best loader for $serverVersion ($serverType) … $stableLoader."
    sleep $INFO_DELAY
    loader=$stableLoader
  else
    dialogInfo "Finding the best loader for $serverVersion ($serverType) … several matches."

    if [ "$KICKSTART" = "$FALSE" ]; then
      dialogYesNo "Several loader matches" "Would you like to install the newer $(textFormatEmphasis "unstable") loader version $(textFormatEmphasis "$anyLoader") rather than the stable $(textFormatEmphasis "$stableLoader")? This is rather not recommended if you are running a stable server version." && loader=$anyLoader || loader=$stableLoader
    else
      loader=$stableLoader # Prefer stable versions in kickstart
    fi
  
  fi

  installerJSON=$(cat $INSTALLER_VER_FILE)
  [ ! "$installerJSON" ] && dialogMessage "Transmission error" "The installer data could not be obtained." && return $FALSE
  installer=$(echo $installerJSON | jq -r ".[0].version")
  
  dialogInfo "Creating directories …"
  serverDir="$OptionJarDir/$(serverPrefix $serverVersion $serverType)"
  mkdir -p $serverDir

  dialogInfo "Downloading $serverType server $serverVersion …"
  download "$FABRIC_API_URL/versions/loader/$serverVersion/$loader/$installer/server/jar" -o "$serverDir/$(serverPrefix $serverVersion $serverType).jar"

  echoBold
  echoBold "#################################"
  echoBold "### Server download completed ###"
  echoBold "#################################"
  echoBold
  
  initServer $serverVersion $serverType
}

# Initialize the server of version $1 and (optionally) type $2, auto-agreeing
# to the EULA if it has already been agreed to through the global options.

initServer () {
  serverVersion="$1"
  [ -z "$2" ] && serverType=$SERVER_TYPE || serverType="$2"

  dialogInfo "Initializing Server …"
  
  serverDir="$OptionJarDir/$(serverPrefix $serverVersion $serverType)"
  cd $serverDir
  
  resetTerminal

  echo $CONFIG_HEADER > eula.txt
  writeConfigKey eula.txt "eula" "$OptionAgreedToEULA"
  writeConfigKey "server.properties" "level-name" "$serverVersion"

  java -jar "$(serverPrefix $serverVersion $serverType).jar" --initSettings --nogui

  cd $SCRIPT_DIR

  echoBold
  echoBold "#######################################"
  echoBold "### Server initialization completed ###"
  echoBold "#######################################"
  echoBold

  [ "$KICKSTART" = "$FALSE" ] && waitForEnter "continue"
  resetTerminal

  # FIXME: Server initially shows as not installed in the server list

  [ "$KICKSTART" = "$FALSE" ] && buildServerLists $serverType
}

# Run the server of version $1 and (optionally) type $2

runServer () {
  serverVersion=$1
  [ "$2" ] && serverType="$2" || serverType=$SERVER_TYPE

  serverDir="$OptionJarDir/$(serverPrefix $serverVersion $serverType)"
  cd $serverDir

  # Agree to the EULA‌ if we have already agreed to it in the global options
  
  echo $CONFIG_HEADER > eula.txt
  writeConfigKey eula.txt "eula" "$OptionAgreedToEULA"
  
  if [ "$KICKSTART" = "$TRUE" ]; then
    dialogInfo "Launching $(TSQ $(textFormatEmphasis $serverVersion \($serverType\)))’. Type $(TSQ $(textFormatEmphasis "/stop")) in the console to shut down the server."
    sleep $LONG_DELAY
  else
    dialogOkCancel "Launching server" "Launching $(TSQ $(textFormatEmphasis $serverVersion \($serverType\)))’. Type the $(textFormatEmphasis "/stop") console command to cleanly exit and return to the launcher." || return $FALSE
  fi
    
  resetTerminal

  echoBold
  echoBold "########################"
  echoBold "### LAUNCHING‌ SERVER ###"
  echoBold "########################"
  echoBold
  echoBold "Version: $serverVersion ($serverType)"
  echoBold "World folder: $OptionWorldDir/$(readConfigKey "server.properties" "level-name")"
  echoBold

  java -Xmx"$OptionJavaMemory" -jar "$(serverPrefix $serverVersion $serverType).jar" --universe $OptionWorldDir --nogui

  echoBold
  echoBold "#################################"
  echoBold "### Server shutdown completed ###"
  echoBold "#################################"
  echoBold
  
  [ "$KICKSTART" = "$FALSE" ] && waitForEnter "return to the launcher"
  resetTerminal

  cd $SCRIPT_DIR
}

## Instant server. Downloads and runs the most recent stable version.

instantServer () {
  lssv=$(getLatestStableServerVersion $SERVER_TYPE)

  if ! isServerInstalled $lssv $SERVER_TYPE; then
    dialogYesNo "Server download" "The latest stable server is not installed. Download the $(TSQ $(textFormatEmphasis $lssv $serverType)) server?" || return
    downloadServer $lssv $SERVER_TYPE
  fi

  runServer $lssv $SERVER_TYPE
  menuInstalledServer $lssv $SERVER_TYPE
}

# Uninstall the server of version $1 and type $2

uninstallServer () {
  serverVersion=$1
  [ "$2" ] && serverType="$2" || serverType=$SERVER_TYPE

  serverDir="$OptionJarDir/$(serverPrefix $serverVersion $serverType)"

  if dialogYesNo "Uninstall server" "Warning: This will delete $(textFormatError "everything") under $(textFormatEmphasis $serverDir), including any local world data! Make sure to have a backup of any needed data. Continue?"; then
    resetTerminal
    
    rm -rfv "$serverDir"

    echoBold
    echoBold "#################################"
    echoBold "### Server deletion completed ###"
    echoBold "#################################"
    echoBold

    waitForEnter "return to the installed servers menu"

    buildServerLists $serverType
    menuMain
  fi
}

# Command line help

help() {
  echo \
"$APP_NAME $APP_VER – 2025-$(date +%Y), originally created by Dennis Murczak
<https://github.com/lortordermur>

Usage: $SCRIPT_NAME <arg>

  -h, --help
  This help screen.
  -k, --kickstart [type]
  Directly run the latest stable server version–downloading, installing and
  initializing it if necessary–and exit afterwards. This skips all user
  interaction except a pending EULA agreement, in which case it quits with an
  error message.
  -n, --no-auto-cache
  Prevents $APP_NAME from automatically refreshing the list cache on startup.
  It can still be refreshed manually from the main menu. This is useful for
  systems that are not always connected to the internet."
  
  # TODO:
  # -r, --run <version> [type]
  # -l, --run-latest [type]
  # -b, --backup <version> [type]
}

# Get and process the command line parameters

processArguments () {
  while [ "$1" ]; do
    # TODO: Shift the parameters so we can combine them
    case $1 in
      -h|--help)
        help
        exit $TRUE ;;
      -k|--kickstart)
        KICKSTART=$TRUE ;;
      -n|--no-auto-cache)
        AUTO_CACHE=$FALSE ;;
      *)
        echo "Unknown parameter! Try --help"
        exit $FALSE ;;
    esac
    
    shift
  done
}

# Stuff to do before showing the main menu

init () {
  
  # Set up logging of stderr to log file while still seeing it onscreen

  exec 2>> $LOG_FILE 2>&1 # FIXME: Creates a 0 byte logfile

  # Create the default directories
  
  mkdir -p $CONFIG_DIR $LIST_CACHE_DIR $DOCS_CACHE_DIR $OptionJarDir $OptionWorldDir

  # Write a default configuration file if there is none

  fileAccessible $CONFIG_FILE || writeDefaultConfig

  # Load the global options and defaults

  fileExists $CONFIG_FILE && loadConfig
  
  # Update the API cache if necessary

  onlineWarning "It seems there is no internet connection. Some functionality will be limited."
  
  [ "$AUTO_CACHE" = "$TRUE" ] && online && needToCache $GAME_VER_FILE $LIST_CACHE_INTERVAL && cacheFabricMeta
  
  [ "$KICKSTART" = "$FALSE" ] && buildServerLists
  
  #online && needToCache $EULA_FILE $EULA_CACHE_INTERVAL && cacheEULA # The EULA should always be cached

  if [ "$KICKSTART" = "$TRUE" ]; then
    dialogInfo "$(textFormatError "Kickstart mode"): Launching the newest server; no frills attached, no questions posed."
    sleep $LONG_DELAY
    kickStart
  fi
}

# Do the kickstart, let’s get down to business.
# $1 (optional) is the desired server type.

kickStart () {
  serverType=$1
  
  lssv=$(getLatestStableServerVersion $serverType)
  [ -z "$lssv" ] && lssv=$(getLatestInstalledServerVersion $serverType)
  [ -z "$lssv" ] && errorExit "KICKSTART: Could not determine the latest server version! Check your internet connection."

  ! isServerInstalled $lssv && downloadServer $lssv $serverType
  runServer $lssv $serverType
  unInit $TRUE
}

# Stuff to do on script exit

unInit () {
  saveConfig

  echo
  echoGreen "Thank you for using $APP_NAME! May the netherite pickaxe be with you."

  [ "$1" ] && exit $1 || exit 0
}

################
# Main program #
################

# Evaluate the command line
  
processArguments $@

# Check for the UI toolkit

! commandExists "dialog" && errorExit "ERROR: The $(TSQ "dialog") command is missing! Please install the $(TSQ "dialog") package."

# Prepare dialogrc pre-init for a custom color scheme
# Drop a dialogrc named ‘colors’ there to customize the appearance

export DIALOGRC="$CONFIG_DIR/colors"
fileExists $DIALOGRC || echo $UI_COLORS > $DIALOGRC

# Root check

if [ $(id -u) = "0" ]; then
  dialogMessage "Root detected" "Running a game server as root $(textFormatError "is a bad idea"). Exiting."
  exit $FALSE
fi

# Software dependency checks

verifyDependency "java" "default-jre-headless"
verifyDependency "curl" "curl"
verifyDependency "jq" "jq"

init
menuMain
